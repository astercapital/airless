{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Airless","text":"<p>Airless is a package that aims to build a serverless and lightweight orchestration platform, creating workflows of multiple tasks being executed on serverless functions. It is build to be Cloud agnostic, so using any Cloud provider is possible</p> <ul> <li>Google Cloud Functions</li> <li>AWS Lambda</li> <li>Azure Functions</li> </ul>"},{"location":"#why-not-just-use-apache-airflow","title":"Why not just use Apache Airflow?","text":"<p>Airflow is the industry standard when we talk about job orchestration and worflow management. However, in some cases, we believe it may not be the best solution. I would like to highlight 3 main cases we face that Airflow struggles to handle.</p> <ul> <li>Serverless</li> </ul> <p>At the beginning of a project we want to avoid dealing with infrastructure since it demands time and it has a fixed cost to reserve an instance to run Airflow. Since we didn't have that many jobs, it didn't make sense to have an instance of Airflow up 24-7. </p> <p>When the project starts to get bigger and, if we use Airflow's instance to run the tasks, we start facing performance issues on the workflow.</p> <p>In order to avoid this problems we decided to build a 100% serverless platform.</p> <ul> <li>Parallel processing</li> </ul> <p>The main use case we designed Airless for is for data scrappers. The problem with data scrappers is that normally you want them to process a lot of tasks in parallel, for instance, first you want to fetch a website and collect all links in that page and send them forward for another task to be executed and then that task does the same and so on and so forth.</p> <p>Building this workflow that does not know before hand how many tasks are going to be executed is something hard be built on Airflow.</p> <ul> <li>Data sharing between tasks</li> </ul> <p>In order to built this massive parallel processing workflow that we explained on the previous topic, we need to be able to dynamically create and send data to the next task. So use the data from the first task as a trigger and an input data for the next tasks. </p>"},{"location":"#architectural-decisions","title":"Architectural Decisions","text":"<ul> <li>Event-Driven Architecture: Utilizes queues to decouple event producers and consumers. Or use HTTP when need synchronous workflows</li> <li>Scalability: Serverless scale automatically based on the number of incoming messages.</li> </ul> <p>Data Flow - Trigger: A message is published to a queue topic or an HTTP request is made. - Cloud Function Invocation: The subscribed serverless service is triggered. - Operator Execution: Processes the message using Airless operators. - Data Storage/Forwarding: Uses hooks to store data in object stores, for example, or publish new messages to other queues.</p> <p>Performance Optimization - Efficient Data Handling: Use hooks to abstract and optimize interactions with external services. - Resource Management: Configure appropriate memory and timeout settings in your serverless service.</p> <p>Security - Least Privilege: Assign the minimum required permissions to service accounts. - Secret Management: Use secret manager to store sensitive information.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>Airless builts its workflows based on serverless functions, queues and schedulers. All of them serverless.</p> <ol> <li>Everything starts with the scheduler, which is able to publish a message to a queue with a cron scheduler</li> <li>When a message is published to the queue it can trigger a serverless function and get executed with that message as an input</li> <li>This serverless function is able to publish as many messages as it wants to as many queue topics as it wants</li> <li>Repeat from 2</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Google Cloud Platform</li> <li>Amazon Web Services</li> <li>Microsoft Azure</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<ul> <li>Make a branch</li> <li>Submete um PR para ver se valida as mudan\u00e7as</li> <li>Depois sobe um PR de release</li> <li>Faz o bumpversion no service que teve mudan\u00e7a de vers\u00e3o</li> <li>Cria uma tag com o nome _v0.x.y<ul> <li><code>git tag -a \"airless-core_v0.1.0\" -m \"first tag\"</code></li> </ul> <li>Faz o push da tag com a nova vers\u00e3o do release<ul> <li><code>git push origin --tags</code></li> </ul> </li> <li>Cada release traz apenas modifica\u00e7\u00f5es de um service</li>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/","title":"Two captcha","text":""},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#solver2captchaservice","title":"Solver2CaptchaService","text":"<p>source</p> <pre><code>Solver2CaptchaService(\n   credentials: dict\n)\n</code></pre> <p>Service for solving captchas using 2Captcha.</p> <p>Methods:</p>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#solve","title":".solve","text":"<p>source</p> <pre><code>.solve(\n   version: str, page_url: str, google_key: str, action: str = 'verify'\n)\n</code></pre> <p>Solves a captcha using the specified version.</p> <p>Args</p> <ul> <li>version (str) : The version of the captcha (e.g., 'v2' or 'v3').</li> <li>page_url (str) : The URL of the page with the captcha.</li> <li>google_key (str) : The Google reCAPTCHA key.</li> <li>action (str, optional) : The action to perform. Defaults to 'verify'.</li> </ul> <p>Raises</p> <ul> <li>Exception  : If the captcha version is not implemented or if solving fails.</li> </ul> <p>Returns</p> <ul> <li>str  : The solution to the captcha.</li> </ul>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#_request_recaptcha_v2","title":"._request_recaptcha_v2","text":"<p>source</p> <pre><code>._request_recaptcha_v2(\n   page_url: str, google_key: str\n)\n</code></pre> <p>Requests solving of a reCAPTCHA v2.</p> <p>Args</p> <ul> <li>page_url (str) : The URL of the page with the captcha.</li> <li>google_key (str) : The Google reCAPTCHA key.</li> </ul>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#_request_recaptcha_v3","title":"._request_recaptcha_v3","text":"<p>source</p> <pre><code>._request_recaptcha_v3(\n   page_url: str, google_key: str, action: str = 'verify'\n)\n</code></pre> <p>Requests solving of a reCAPTCHA v3.</p> <p>Args</p> <ul> <li>page_url (str) : The URL of the page with the captcha.</li> <li>google_key (str) : The Google reCAPTCHA key.</li> <li>action (str, optional) : The action to perform. Defaults to 'verify'.</li> </ul>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#report_bad_captcha","title":".report_bad_captcha","text":"<p>source</p> <pre><code>.report_bad_captcha()\n</code></pre> <p>Reports a captcha as unsolvable.</p>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#_send_request","title":"._send_request","text":"<p>source</p> <pre><code>._send_request(\n   params: dict\n)\n</code></pre> <p>Sends a request to the 2Captcha API.</p> <p>Args</p> <ul> <li>params (dict) : The parameters for the request.</li> </ul> <p>Raises</p> <ul> <li>HTTPError  : If the request fails.</li> </ul>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#_send_response_request","title":"._send_response_request","text":"<p>source</p> <pre><code>._send_response_request(\n   action: str\n)\n</code></pre> <p>Sends a request to get the response of the captcha.</p> <p>Args</p> <ul> <li>action (str) : The action to perform (e.g., 'get', 'reportgood', 'reportbad').</li> </ul> <p>Returns</p> <ul> <li>dict  : The response from the 2Captcha API.</li> </ul> <p>Raises</p> <ul> <li>HTTPError  : If the request fails.</li> </ul>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#init","title":".init","text":"<p>source</p> <pre><code>.__init__(\n   credentials: dict\n)\n</code></pre> <p>Initializes the Solver2CaptchaService.</p> <p>Args</p> <ul> <li>credentials (dict) : The credentials for the 2Captcha API.</li> </ul>"},{"location":"packages/airless-captcha/airless/captcha/providers/two_captcha/#report_good_captcha","title":".report_good_captcha","text":"<p>source</p> <pre><code>.report_good_captcha()\n</code></pre> <p>Reports a captcha as solved successfully.</p>"},{"location":"packages/airless-core/airless/core/base/","title":"Base","text":""},{"location":"packages/airless-core/airless/core/base/#baseclass","title":"BaseClass","text":"<p>source</p> <p>Base class for all components with logging capabilities.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/base/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the BaseClass and sets up logging.</p>"},{"location":"packages/airless-core/airless/core/dto/base/","title":"Base","text":""},{"location":"packages/airless-core/airless/core/dto/base/#basedto","title":"BaseDto","text":"<p>source</p> <pre><code>BaseDto(\n   event_id: int, resource: str, to_project: str, to_dataset: str, to_table: str,\n   to_schema: list, to_partition_column: str, to_extract_to_cols: bool,\n   to_keys_format: str, data: dict\n)\n</code></pre> <p>Base Data Transfer Object for handling data.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/dto/base/#init","title":".init","text":"<p>source</p> <pre><code>.__init__(\n   event_id: int, resource: str, to_project: str, to_dataset: str, to_table: str,\n   to_schema: list, to_partition_column: str, to_extract_to_cols: bool,\n   to_keys_format: str, data: dict\n)\n</code></pre> <p>Initializes the BaseDto.</p> <p>Args</p> <ul> <li>event_id (int) : The event ID.</li> <li>resource (str) : The resource name.</li> <li>to_project (str) : The target project.</li> <li>to_dataset (str) : The target dataset.</li> <li>to_table (str) : The target table.</li> <li>to_schema (list) : The schema for the data.</li> <li>to_partition_column (str) : The partition column.</li> <li>to_extract_to_cols (bool) : Flag to extract columns.</li> <li>to_keys_format (str) : The format for keys.</li> <li>data (dict) : The data to be transferred.</li> </ul>"},{"location":"packages/airless-core/airless/core/dto/base/#as_dict","title":".as_dict","text":"<p>source</p> <pre><code>.as_dict()\n</code></pre> <p>Converts the DTO to a dictionary.</p> <p>Returns</p> <ul> <li>dict  : The dictionary representation of the DTO.</li> </ul>"},{"location":"packages/airless-core/airless/core/dto/base/#from_dict","title":".from_dict","text":"<p>source</p> <pre><code>.from_dict(\n   d: dict\n)\n</code></pre> <p>Creates a BaseDto from a dictionary.</p> <p>Args</p> <ul> <li>d (dict) : The dictionary to convert.</li> </ul> <p>Returns</p> <ul> <li>BaseDto  : The created BaseDto instance.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/base/","title":"Base","text":""},{"location":"packages/airless-core/airless/core/hook/base/#basehook","title":"BaseHook","text":"<p>source</p> <p>Base class for hooks in the system.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/hook/base/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the BaseHook.</p>"},{"location":"packages/airless-core/airless/core/hook/email/","title":"Email","text":""},{"location":"packages/airless-core/airless/core/hook/email/#emailhook","title":"EmailHook","text":"<p>source</p> <p>EmailHook class to build and send email messages.</p> <p>This class is responsible for constructing email messages that may  include attachments and other related information. However, the  sending functionality is not implemented.</p> <p>Inherits from: BaseHook: The base class for hooks in the airless framework.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/hook/email/#send","title":".send","text":"<p>source</p> <pre><code>.send(\n   subject: str, content: str, recipients: list, sender: str, attachments: list,\n   mime_type: str\n)\n</code></pre> <p>Sends the constructed email message.</p> <p>This method is not implemented and will raise a NotImplementedError.</p> <p>Args</p> <ul> <li>subject (str) : The subject of the email.</li> <li>content (str) : The body content of the email.</li> <li>recipients (list) : A list of recipient email addresses.</li> <li>sender (str) : The email address of the sender.</li> <li>attachments (list) : A list of attachment dictionaries.</li> <li>mime_type (str) : The MIME type of the email body content.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method has not been implemented.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/email/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the EmailHook class.</p> <p>This constructor calls the superclass constructor.</p>"},{"location":"packages/airless-core/airless/core/hook/email/#build_message","title":".build_message","text":"<p>source</p> <pre><code>.build_message(\n   subject: str, content: str, recipients: list, sender: str, attachments: list = [],\n   mime_type: str = 'plain'\n)\n</code></pre> <p>Builds an email message with optional attachments.</p> <p>Args</p> <ul> <li>subject (str) : The subject of the email.</li> <li>content (str) : The body content of the email.</li> <li>recipients (list) : A list of recipient email addresses.</li> <li>sender (str) : The email address of the sender.</li> <li>attachments (list, optional) : A list of attachment dictionaries.      Each dictionary should contain 'name', 'content', and optionally 'type'.      Defaults to an empty list.</li> <li>mime_type (str, optional) : The MIME type of the email body content.      Defaults to 'plain'.</li> </ul> <p>Returns</p> <ul> <li>MIMEText  : The constructed email message object.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/","title":"File","text":""},{"location":"packages/airless-core/airless/core/hook/file/#filehook","title":"FileHook","text":"<p>source</p> <p>FileHook class for handling file operations.</p> <p>This class provides methods to write data to local files in various formats (JSON and NDJSON), download files, rename files, and list files in a directory.</p> <p>Inherits from: BaseHook: The base class for hooks in the airless framework.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/hook/file/#extract_filename","title":".extract_filename","text":"<p>source</p> <pre><code>.extract_filename(\n   filepath_or_url\n)\n</code></pre> <p>Extracts the filename from a filepath or URL.</p> <p>Args</p> <ul> <li>filepath_or_url (str) : The original file path or URL.</li> </ul> <p>Returns</p> <ul> <li>str  : The extracted filename.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#download","title":".download","text":"<p>source</p> <pre><code>.download(\n   url, headers, timeout = 500, proxies = None\n)\n</code></pre> <p>Downloads a file from a given URL and saves it to a temporary path.</p> <p>Args</p> <ul> <li>url (str) : The URL of the file to download.</li> <li>headers (dict) : The headers to include in the request.</li> <li>timeout (int, optional) : The request timeout in seconds. Defaults to 500.</li> <li>proxies (dict, optional) : Proxy settings for the request. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>str  : The local filename where the downloaded file is saved.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#rename","title":".rename","text":"<p>source</p> <pre><code>.rename(\n   from_filename, to_filename\n)\n</code></pre> <p>Renames a file from the original filename to the new filename.</p> <p>Args</p> <ul> <li>from_filename (str) : The original filename to rename.</li> <li>to_filename (str) : The new filename.</li> </ul> <p>Returns</p> <ul> <li>str  : The new filename after renaming.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#rename_files","title":".rename_files","text":"<p>source</p> <pre><code>.rename_files(\n   dir, prefix\n)\n</code></pre> <p>Renames all files in a directory by prepending a prefix.</p> <p>Args</p> <ul> <li>dir (str) : The directory containing files to rename.</li> <li>prefix (str) : The prefix to prepend to each file name.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#write","title":".write","text":"<p>source</p> <pre><code>.write(\n   local_filepath: str, data: Any, **kwargs\n)\n</code></pre> <p>Writes data to a local file with support for JSON and NDJSON formats.</p> <p>Args</p> <p>local_filepath (str):     The path to the local file where the data will be written. data (Any):     The data to write to the file. It can be a string, dictionary, list,     or any other type that can be serialized to JSON or converted to a string.</p> <p>Kwargs:     use_ndjson (bool):         If <code>True</code> and the data is a dictionary or list, the data will be         written in NDJSON format. Defaults to <code>False</code>.     mode (str):         The mode in which the file is opened. Common modes include:         Defaults to <code>'w'</code>.</p>"},{"location":"packages/airless-core/airless/core/hook/file/#get_tmp_filepath","title":".get_tmp_filepath","text":"<p>source</p> <pre><code>.get_tmp_filepath(\n   filepath_or_url: str, **kwargs\n)\n</code></pre> <p>Generates a temporary file path based on the provided filepath or URL.</p> <p>Args</p> <p>filepath_or_url (str):     The original file path or URL from which the filename is extracted.</p> <p>Kwargs:     add_timestamp (bool, optional):         If <code>True</code>, a timestamp and a UUID will be prefixed to the filename to ensure uniqueness.         Defaults to <code>True</code>.</p> <p>Returns</p> <ul> <li>str  : The temporary file path.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#list_files","title":".list_files","text":"<p>source</p> <pre><code>.list_files(\n   folder\n)\n</code></pre> <p>Lists all files in a specified directory.</p> <p>Args</p> <ul> <li>folder (str) : The folder path to search for files.</li> </ul> <p>Returns</p> <ul> <li>list  : A list of file paths found in the directory.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes a new instance of the FileHook class.</p>"},{"location":"packages/airless-core/airless/core/hook/file/#ftphook","title":"FtpHook","text":"<p>source</p> <p>FtpHook class for handling FTP file operations.</p> <p>This class extends FileHook with methods specific to FTP file operations including connecting to an FTP server, navigating directories, and downloading files.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/hook/file/#list","title":".list","text":"<p>source</p> <pre><code>.list(\n   regex = None, updated_after = None, updated_before = None\n)\n</code></pre> <p>Lists files in the current directory of the FTP server with optional filters.</p> <p>Args</p> <ul> <li>regex (str, optional) : A regular expression to filter file names. Defaults to None.</li> <li>updated_after (datetime, optional) : Filter files updated after this date. Defaults to None.</li> <li>updated_before (datetime, optional) : Filter files updated before this date. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>tuple  : A tuple containing two lists:<ul> <li>A list of files (dictionaries with 'name' and 'updated_at').</li> <li>A list of directories (dictionaries with 'name' and 'updated_at').</li> </ul> </li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#login","title":".login","text":"<p>source</p> <pre><code>.login(\n   host, user, password\n)\n</code></pre> <p>Logs into the FTP server using the provided credentials.</p> <p>Args</p> <ul> <li>host (str) : The FTP server hostname or IP address.</li> <li>user (str) : The username for the FTP server.</li> <li>password (str) : The password for the FTP server.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#download_1","title":".download","text":"<p>source</p> <pre><code>.download(\n   dir, filename\n)\n</code></pre> <p>Downloads a file from the FTP server to a temporary local file.</p> <p>Args</p> <ul> <li>dir (str) : The directory on the FTP server where the file is located.</li> <li>filename (str) : The name of the file to download.</li> </ul> <p>Returns</p> <ul> <li>str  : The local filepath where the downloaded file is saved.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#cwd","title":".cwd","text":"<p>source</p> <pre><code>.cwd(\n   dir\n)\n</code></pre> <p>Changes the current working directory on the FTP server.</p> <p>Args</p> <ul> <li>dir (str) : The directory to change to.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#dir","title":".dir","text":"<p>source</p> <pre><code>.dir()\n</code></pre> <p>Lists the files and directories in the current directory of the FTP server.</p> <p>This method retrieves a list of files and directories from the FTP server's  current working directory. It populates a list with the directory entries  and returns it.</p> <p>Returns</p> <ul> <li>list  : A list of directory entries as strings, each representing a file  or directory in the FTP server's current working directory.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/file/#init_1","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes a new instance of the FtpHook class.</p>"},{"location":"packages/airless-core/airless/core/hook/llm/","title":"Llm","text":""},{"location":"packages/airless-core/airless/core/hook/llm/#llmhook","title":"LLMHook","text":"<p>source</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/hook/llm/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre>"},{"location":"packages/airless-core/airless/core/hook/llm/#generate_completion","title":".generate_completion","text":"<p>source</p> <pre><code>.generate_completion(\n   content, **kwargs\n)\n</code></pre>"},{"location":"packages/airless-core/airless/core/hook/llm/#historic_append","title":".historic_append","text":"<p>source</p> <pre><code>.historic_append(\n   text, actor\n)\n</code></pre>"},{"location":"packages/airless-core/airless/core/hook/queue/","title":"Queue","text":""},{"location":"packages/airless-core/airless/core/hook/queue/#queuehook","title":"QueueHook","text":"<p>source</p> <p>Hook for interacting with a queue system.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/hook/queue/#publish","title":".publish","text":"<p>source</p> <pre><code>.publish(\n   project: str, topic: str, data: dict\n)\n</code></pre> <p>Publishes data to a specified topic.</p> <p>Args</p> <ul> <li>project (str) : The project name.</li> <li>topic (str) : The topic to publish to.</li> <li>data (dict) : The data to publish.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method needs to be implemented in a subclass.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/queue/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the QueueHook.</p>"},{"location":"packages/airless-core/airless/core/hook/secret/","title":"Secret","text":""},{"location":"packages/airless-core/airless/core/hook/secret/#secretmanagerhook","title":"SecretManagerHook","text":"<p>source</p> <p>Hook for interacting with a secret management system.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/hook/secret/#add_secret_version","title":".add_secret_version","text":"<p>source</p> <pre><code>.add_secret_version(\n   project: str, id: str, value: str\n)\n</code></pre> <p>Adds a new version of a secret.</p> <p>Args</p> <ul> <li>project (str) : The project name.</li> <li>id (str) : The ID of the secret.</li> <li>value (str) : The value of the secret.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method needs to be implemented in a subclass.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/secret/#get_secret","title":".get_secret","text":"<p>source</p> <pre><code>.get_secret(\n   project: str, id: str, parse_json: bool = False\n)\n</code></pre> <p>Retrieves a secret.</p> <p>Args</p> <ul> <li>project (str) : The project name.</li> <li>id (str) : The ID of the secret.</li> <li>parse_json (bool, optional) : Whether to parse the secret as JSON. Defaults to False.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method needs to be implemented in a subclass.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/secret/#list_secrets","title":".list_secrets","text":"<p>source</p> <pre><code>.list_secrets()\n</code></pre> <p>Lists all secrets.</p> <p>Raises</p> <ul> <li>NotImplementedError  : This method needs to be implemented in a subclass.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/secret/#list_secret_versions","title":".list_secret_versions","text":"<p>source</p> <pre><code>.list_secret_versions(\n   secret_name: str, filter: str\n)\n</code></pre> <p>Lists all versions of a specific secret.</p> <p>Args</p> <ul> <li>secret_name (str) : The name of the secret.</li> <li>filter (str) : The filter to apply.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method needs to be implemented in a subclass.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/secret/#destroy_secret_version","title":".destroy_secret_version","text":"<p>source</p> <pre><code>.destroy_secret_version(\n   secret_name: str, version: str\n)\n</code></pre> <p>Destroys a specific version of a secret.</p> <p>Args</p> <ul> <li>secret_name (str) : The name of the secret.</li> <li>version (str) : The version of the secret to destroy.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method needs to be implemented in a subclass.</li> </ul>"},{"location":"packages/airless-core/airless/core/hook/secret/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the SecretManagerHook.</p>"},{"location":"packages/airless-core/airless/core/operator/base/","title":"Base","text":""},{"location":"packages/airless-core/airless/core/operator/base/#baseoperator","title":"BaseOperator","text":"<p>source</p> <p>BaseOperator class to handle message operations.</p> <p>This class provides the foundational functionality for various  operators that can handle different triggers, such as events,  files, and HTTP requests. It includes basic error handling  and message chaining functionalities.</p> <p>Inherits from: BaseClass: The base class for the operator implementations.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/operator/base/#chain_messages","title":".chain_messages","text":"<p>source</p> <pre><code>.chain_messages(\n   messages: list\n)\n</code></pre> <p>Chains messages together for processing.</p> <p>Args</p> <ul> <li>messages (list) : A list of messages to chain.</li> </ul> <p>Returns</p> <ul> <li>tuple  : A tuple containing chained message data and the first topic.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#build_error_message","title":".build_error_message","text":"<p>source</p> <pre><code>.build_error_message(\n   message: str, data: dict\n)\n</code></pre> <p>Builds an error message.</p> <p>This method needs to be implemented in subclasses.</p> <p>Args</p> <ul> <li>message (str) : The error message.</li> <li>data (dict) : The associated data.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method should be implemented by subclasses.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#report_error","title":".report_error","text":"<p>source</p> <pre><code>.report_error(\n   message: str, data: dict = None\n)\n</code></pre> <p>Reports an error by logging it and publishing to a queue.</p> <p>Args</p> <ul> <li>message (str) : The error message to report.</li> <li>data (dict, optional) : Additional data associated with the error. Defaults to None.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the BaseOperator class.</p> <p>Sets up necessary attributes for the operator including  a QueueHook instance for message publishing.</p>"},{"location":"packages/airless-core/airless/core/operator/base/#extract_message_id","title":".extract_message_id","text":"<p>source</p> <pre><code>.extract_message_id(\n   cloud_event\n)\n</code></pre> <p>Extracts the message ID from the cloud event.</p> <p>Args</p> <ul> <li>cloud_event (CloudEvent) : The cloud event from which to extract the message ID.</li> </ul> <p>Returns</p> <ul> <li>str  : The extracted message ID.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#basefileoperator","title":"BaseFileOperator","text":"<p>source</p> <p>BaseFileOperator class to handle file trigger operations.</p> <p>This class extends BaseOperator for operations triggered by files.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/operator/base/#build_error_message_1","title":".build_error_message","text":"<p>source</p> <pre><code>.build_error_message(\n   message: str, data: dict\n)\n</code></pre> <p>Builds an error message specific to file operations.</p> <p>Args</p> <ul> <li>message (str) : The error message.</li> <li>data (dict) : The associated data.</li> </ul> <p>Returns</p> <ul> <li>dict  : A constructed error message.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#init_1","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the BaseFileOperator class.</p> <p>Sets the trigger type to 'file' and initializes necessary attributes.</p>"},{"location":"packages/airless-core/airless/core/operator/base/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   bucket: str, filepath: str\n)\n</code></pre> <p>Executes file processing logic.</p> <p>This method needs to be implemented in subclasses.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the bucket where the file is located.</li> <li>filepath (str) : The path to the file within the bucket.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method should be implemented by subclasses.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#run","title":".run","text":"<p>source</p> <pre><code>.run(\n   cloud_event\n)\n</code></pre> <p>Processes the incoming cloud event and executes file logic.</p> <p>Args</p> <ul> <li>cloud_event (CloudEvent) : The cloud event containing metadata about the file.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#baseeventoperator","title":"BaseEventOperator","text":"<p>source</p> <p>BaseEventOperator class to handle event trigger operations.</p> <p>This class extends BaseOperator for operations triggered by events.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/operator/base/#run_next","title":".run_next","text":"<p>source</p> <pre><code>.run_next(\n   tasks: list\n)\n</code></pre> <p>Executes the next tasks in the pipeline.</p> <p>Args</p> <ul> <li>tasks (list) : A list of tasks to execute next.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#execute_1","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: dict, topic: str\n)\n</code></pre> <p>Executes event processing logic.</p> <p>This method needs to be implemented in subclasses.</p> <p>Args</p> <ul> <li>data (dict) : The data associated with the event.</li> <li>topic (str) : The event topic.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method should be implemented by subclasses.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#build_error_message_2","title":".build_error_message","text":"<p>source</p> <pre><code>.build_error_message(\n   message: str, data: dict\n)\n</code></pre> <p>Builds an error message specific to event operations.</p> <p>Args</p> <ul> <li>message (str) : The error message.</li> <li>data (dict) : The associated data.</li> </ul> <p>Returns</p> <ul> <li>dict  : A constructed error message.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#run_1","title":".run","text":"<p>source</p> <pre><code>.run(\n   cloud_event\n)\n</code></pre> <p>Processes the incoming cloud event and executes event logic.</p> <p>Args</p> <ul> <li>cloud_event (CloudEvent) : The cloud event containing metadata about the event.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#init_2","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the BaseEventOperator class.</p> <p>Sets the trigger type to 'event' and initializes necessary attributes.</p>"},{"location":"packages/airless-core/airless/core/operator/base/#basehttpoperator","title":"BaseHttpOperator","text":"<p>source</p> <p>BaseHttpOperator class to handle HTTP trigger operations.</p> <p>This class extends BaseOperator for operations triggered by HTTP requests.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/operator/base/#build_error_message_3","title":".build_error_message","text":"<p>source</p> <pre><code>.build_error_message(\n   message, request\n)\n</code></pre> <p>Builds an error message specific to HTTP operations.</p> <p>Args</p> <ul> <li>message (str) : The error message.</li> <li>request (Request) : The HTTP request object.</li> </ul> <p>Returns</p> <ul> <li>dict  : A constructed error message.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#init_3","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the BaseHttpOperator class.</p> <p>Sets the trigger type to 'http' and initializes necessary attributes.</p>"},{"location":"packages/airless-core/airless/core/operator/base/#execute_2","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   request\n)\n</code></pre> <p>Executes HTTP request processing logic.</p> <p>This method needs to be implemented in subclasses.</p> <p>Args</p> <ul> <li>request (Request) : The HTTP request object.</li> </ul> <p>Raises</p> <ul> <li>NotImplementedError  : This method should be implemented by subclasses.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/base/#run_2","title":".run","text":"<p>source</p> <pre><code>.run(\n   request\n)\n</code></pre> <p>Processes the incoming HTTP request and executes processing logic.</p> <p>Args</p> <ul> <li>request (Request) : The HTTP request object.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/delay/","title":"Delay","text":""},{"location":"packages/airless-core/airless/core/operator/delay/#delayoperator","title":"DelayOperator","text":"<p>source</p> <p>Operator that adds a delay to the pipeline.</p> <p>This operator introduces a delay in the processing pipeline by sleeping for a specified amount of time in seconds. The maximum delay that can be set is capped at 500 seconds.</p> <p>Attributes</p> <p>None</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/operator/delay/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes a DelayOperator instance.</p> <p>This method calls the constructor of the parent class  <code>BaseEventOperator</code>.</p>"},{"location":"packages/airless-core/airless/core/operator/delay/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: dict, topic: str\n)\n</code></pre> <p>Executes the delay operation.</p> <p>Args</p> <ul> <li>data (dict) : A dictionary containing a key 'seconds' which     determines how many seconds the operator should wait.</li> <li>topic  : The topic to which the event is associated. This parameter     is not utilized in this operator.</li> </ul> <p>Raises</p> <ul> <li>KeyError  : If the 'seconds' key is not present in the data dictionary.</li> </ul> <p>The function sleeps for the number of seconds specified, capping the maximum wait time at 500 seconds.</p>"},{"location":"packages/airless-core/airless/core/operator/error/","title":"Error","text":""},{"location":"packages/airless-core/airless/core/operator/error/#errorreprocessoperator","title":"ErrorReprocessOperator","text":"<p>source</p> <p>Operator to handle processing of erroneous events.</p> <p>This operator manages the retry logic for events that fail. It can reprocess events based on configured retries and intervals,  and if the maximum retries are exceeded, it forwards the error  details to a specified destination.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/operator/error/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the ErrorReprocessOperator.</p> <p>Inherits from the BaseEventOperator and performs any necessary  initialization.  </p>"},{"location":"packages/airless-core/airless/core/operator/error/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data, topic\n)\n</code></pre> <p>Executes the error processing logic for the given data.</p> <p>Args</p> <ul> <li>data (dict) : The event data that needs to be processed.</li> <li>topic (str) : The topic from which the event is received.</li> </ul> <p>Raises</p> <ul> <li>KeyError  : If required keys are missing in the data dictionary.</li> </ul> <p>This method retrieves necessary metadata from the input data,  handles retries based on the specified parameters, and publishes  either the retried event back to the original topic or the  error details to the destination topic if maximum retries have  been exceeded.</p>"},{"location":"packages/airless-core/airless/core/operator/redirect/","title":"Redirect","text":""},{"location":"packages/airless-core/airless/core/operator/redirect/#redirectoperator","title":"RedirectOperator","text":"<p>source</p> <p>Operator that receives one event from a queue topic and publishes multiple  messages to another topic.</p> <p>Parameters: event: The event received from the queue topic. project (str): The project where the destination queue is hosted. topic (str): The queue topic to which the newly generated messages will be published. messages (list): A list of messages to publish to the topic. params (list of dict): A list of dictionaries containing a key and a list of values.</p> <p>Returns</p> <ul> <li>list  : A list of output messages, which will be the product of the initial messages        and every list of values in params.</li> </ul> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/operator/redirect/#add_params_to_messages","title":".add_params_to_messages","text":"<p>source</p> <pre><code>.add_params_to_messages(\n   messages: list, params: list\n)\n</code></pre> <p>Adds parameters to each message in a list of messages.</p> <p>Args</p> <ul> <li>messages (list) : A list of messages to be modified.</li> <li>params (list of dict) : A list of parameter dictionaries, each containing     a key and a list of values.</li> </ul> <p>Returns</p> <ul> <li>list  : A list of messages with the parameters added.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/redirect/#add_param_to_message","title":".add_param_to_message","text":"<p>source</p> <pre><code>.add_param_to_message(\n   message: dict, param: dict\n)\n</code></pre> <p>Adds a parameter's values to a single message.</p> <p>Args</p> <ul> <li>message (dict) : The original message to which parameters will be added.</li> <li>param (dict) : A dictionary containing a 'key' and a list of 'values'.</li> </ul> <p>Returns</p> <ul> <li>list  : A list of new messages with the parameter added.</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/redirect/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: dict, topic: str\n)\n</code></pre> <p>Executes the operator, publishing messages to a specified topic.</p> <p>Args</p> <ul> <li>data (dict) : A dictionary containing event data with keys:<ul> <li>project (str): The project where the destination queue is hosted.</li> <li>topic (str): The queue topic to which the newly generated messages will be published.</li> <li>messages (list): A list of initial messages to publish.</li> <li>params (list of dict): A list of parameters to modify the messages.</li> </ul> </li> <li>topic (str) : The topic to publish the messages to.</li> </ul> <p>Returns</p> <p>None</p>"},{"location":"packages/airless-core/airless/core/operator/redirect/#add_key","title":".add_key","text":"<p>source</p> <pre><code>.add_key(\n   obj: dict, keys: list, value: Any\n)\n</code></pre> <p>Adds a value to a nested dictionary at a specified key path.</p> <p>This method takes an object (dictionary), a list of keys representing  a path to a location in that dictionary, and a value to insert at  that location. If the specified nested keys do not exist in the  dictionary, they will be created.</p> <p>Args</p> <ul> <li>obj (dict) : The dictionary to which the keys and value will be added.</li> <li>keys (list) : A list of keys representing the path in the dictionary.</li> <li>value  : The value to be set at the specified key path.</li> </ul> <p>Returns</p> <ul> <li>dict  : A new dictionary with the value added at the specified key path.</li> </ul> <p>Example</p> <ul> <li>{'b': 1}}</li> <li>{'b': 1, 'c': 2}} keys = ['a', 'c'] value = 2 result = add_key(self, obj, keys, value)</li> </ul>"},{"location":"packages/airless-core/airless/core/operator/redirect/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the RedirectOperator.</p>"},{"location":"packages/airless-core/airless/core/operator/redirect/#add_param_to_messages","title":".add_param_to_messages","text":"<p>source</p> <pre><code>.add_param_to_messages(\n   messages: list, param: dict\n)\n</code></pre> <p>Adds a single parameter to each message in a list of messages.</p> <p>Args</p> <ul> <li>messages (list) : A list of messages to modify.</li> <li>param (dict) : A dictionary containing a 'key' and 'values'.</li> </ul> <p>Returns</p> <ul> <li>list  : A list of modified messages with the parameter added.</li> </ul>"},{"location":"packages/airless-core/airless/core/service/base/","title":"Base","text":""},{"location":"packages/airless-core/airless/core/service/base/#baseservice","title":"BaseService","text":"<p>source</p> <p>Base class for services in the system.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/service/base/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the BaseService.</p>"},{"location":"packages/airless-core/airless/core/service/captcha/","title":"Captcha","text":""},{"location":"packages/airless-core/airless/core/service/captcha/#captchaservice","title":"CaptchaService","text":"<p>source</p> <p>Service for solving captchas.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/service/captcha/#solve","title":".solve","text":"<p>source</p> <pre><code>.solve(\n   version: str, key: str, url: str, action: str = 'verify'\n)\n</code></pre> <p>Solves a captcha.</p> <p>Args</p> <ul> <li>version (str) : The version of the captcha (e.g., 'v2' or 'v3').</li> <li>key (str) : The captcha key.</li> <li>url (str) : The URL where the captcha is located.</li> <li>action (str, optional) : The action to perform. Defaults to 'verify'.</li> </ul> <p>Raises</p> <ul> <li>Exception  : If the captcha version is not implemented.</li> </ul> <p>Returns</p> <ul> <li>str  : The solution to the captcha.</li> </ul>"},{"location":"packages/airless-core/airless/core/service/captcha/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the CaptchaService.</p>"},{"location":"packages/airless-core/airless/core/utils/config/","title":"Config","text":""},{"location":"packages/airless-core/airless/core/utils/config/#get_config","title":"get_config","text":"<p>source</p> <pre><code>.get_config(\n   key: str, raise_exception: bool = True, default_value: str = None\n)\n</code></pre> <p>Retrieves the configuration value for a given key.</p> <p>Args</p> <ul> <li>key (str) : The configuration key to retrieve.</li> <li>raise_exception (bool, optional) : Whether to raise an exception if the key is not found. Defaults to True.</li> <li>default_value (str, optional) : The default value to return if the key is not found. Defaults to None.</li> </ul> <p>Raises</p> <ul> <li>Exception  : If the key is not found and raise_exception is True.</li> </ul> <p>Returns</p> <ul> <li>str  : The configuration value.</li> </ul>"},{"location":"packages/airless-core/airless/core/utils/enum/","title":"Enum","text":""},{"location":"packages/airless-core/airless/core/utils/enum/#baseenum","title":"BaseEnum","text":"<p>source</p> <pre><code>BaseEnum()\n</code></pre> <p>Base class for enumerations.</p> <p>Methods:</p>"},{"location":"packages/airless-core/airless/core/utils/enum/#list","title":".list","text":"<p>source</p> <pre><code>.list(\n   cls\n)\n</code></pre> <p>Lists all enumeration values.</p> <p>Returns</p> <ul> <li>list  : A list of enumeration values.</li> </ul>"},{"location":"packages/airless-core/airless/core/utils/enum/#find_by_id","title":".find_by_id","text":"<p>source</p> <pre><code>.find_by_id(\n   cls, id: str\n)\n</code></pre> <p>Finds an enumeration by its ID.</p> <p>Args</p> <ul> <li>id (str) : The ID to search for.</li> </ul> <p>Returns</p> <ul> <li>BaseEnum  : The found enumeration or None if not found.</li> </ul>"},{"location":"packages/airless-core/airless/core/utils/enum/#eq","title":".eq","text":"<p>source</p> <pre><code>.__eq__(\n   other\n)\n</code></pre> <p>Checks equality with another object.</p> <p>Args</p> <ul> <li>other (BaseEnum | dict | str) : The object to compare with.</li> </ul> <p>Returns</p> <ul> <li>bool  : True if equal, False otherwise.</li> </ul>"},{"location":"packages/airless-email/airless/email/hook/email/","title":"Email","text":""},{"location":"packages/airless-email/airless/email/hook/email/#googleemailhook","title":"GoogleEmailHook","text":"<p>source</p> <p>Hook for sending emails using Google Email service.</p> <p>Methods:</p>"},{"location":"packages/airless-email/airless/email/hook/email/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleEmailHook.</p>"},{"location":"packages/airless-email/airless/email/hook/email/#send","title":".send","text":"<p>source</p> <pre><code>.send(\n   subject: str, content: str, recipients: List[str], sender: str,\n   attachments: List[dict], mime_type: str\n)\n</code></pre> <p>Sends an email.</p> <p>Args</p> <ul> <li>subject (str) : The subject of the email.</li> <li>content (str) : The content of the email.</li> <li>recipients (List[str]) : The list of email recipients.</li> <li>sender (str) : The sender's email address.</li> <li>attachments (List[dict]) : The list of attachments.</li> <li>mime_type (str) : The MIME type of the email content.</li> </ul>"},{"location":"packages/airless-email/airless/email/operator/email/","title":"Email","text":""},{"location":"packages/airless-email/airless/email/operator/email/#googleemailsendoperator","title":"GoogleEmailSendOperator","text":"<p>source</p> <p>Operator for sending emails using Google Email Hook.</p> <p>Methods:</p>"},{"location":"packages/airless-email/airless/email/operator/email/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleEmailSendOperator.</p>"},{"location":"packages/airless-email/airless/email/operator/email/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: dict, topic: str\n)\n</code></pre> <p>Executes the email sending process.</p> <p>Args</p> <ul> <li>data (dict) : The data containing email information.</li> <li>topic (str) : The Pub/Sub topic.</li> </ul>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/","title":"Bigquery","text":""},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#bigqueryhook","title":"BigqueryHook","text":"<p>source</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#load_file","title":".load_file","text":"<p>source</p> <pre><code>.load_file(\n   from_filepath, from_file_format, from_separator, from_skip_leading_rows,\n   from_quote_character, from_encoding, to_project, to_dataset, to_table,\n   to_mode, to_schema, to_time_partitioning\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#execute_query_job","title":".execute_query_job","text":"<p>source</p> <pre><code>.execute_query_job(\n   query, to_project, to_dataset, to_table, to_write_disposition,\n   to_time_partitioning, timeout = 480\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#list_datasets","title":".list_datasets","text":"<p>source</p> <pre><code>.list_datasets()\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#build_table_id","title":".build_table_id","text":"<p>source</p> <pre><code>.build_table_id(\n   project, dataset, table\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#export_to_gcs","title":".export_to_gcs","text":"<p>source</p> <pre><code>.export_to_gcs(\n   from_project, from_dataset, from_table, to_filepath\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#get_table","title":".get_table","text":"<p>source</p> <pre><code>.get_table(\n   project, dataset, table, schema, partition_column\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#get_all_columns","title":".get_all_columns","text":"<p>source</p> <pre><code>.get_all_columns(\n   rows\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#get_rows_from_table","title":".get_rows_from_table","text":"<p>source</p> <pre><code>.get_rows_from_table(\n   project, dataset, table, timeout = 480\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#write","title":".write","text":"<p>source</p> <pre><code>.write(\n   project, dataset, table, schema, partition_column, rows\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#get_dataset","title":".get_dataset","text":"<p>source</p> <pre><code>.get_dataset(\n   dataset\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#setup_job_config","title":".setup_job_config","text":"<p>source</p> <pre><code>.setup_job_config(\n   from_file_format, from_separator, from_skip_leading_rows,\n   from_quote_character, from_encoding, to_mode, to_schema,\n   to_time_partitioning\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#update_table_schema","title":".update_table_schema","text":"<p>source</p> <pre><code>.update_table_schema(\n   bq_table, rows\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#execute_load_job","title":".execute_load_job","text":"<p>source</p> <pre><code>.execute_load_job(\n   from_filepath, to_project, to_dataset, to_table, job_config, timeout = 240\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/hook/bigquery/#get_query_results","title":".get_query_results","text":"<p>source</p> <pre><code>.get_query_results(\n   query, timeout = 480\n)\n</code></pre>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/","title":"Bigquery","text":""},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#gcsquerytobigqueryoperator","title":"GcsQueryToBigqueryOperator","text":"<p>source</p> <p>Operator for executing queries from GCS to BigQuery.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GcsQueryToBigqueryOperator.</p>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: Dict[str, Any], topic: str\n)\n</code></pre> <p>Executes the query from GCS to BigQuery.</p> <p>Args</p> <ul> <li>data (Dict[str, Any]) : The data containing query information.</li> <li>topic (str) : The Pub/Sub topic.</li> </ul>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#pubsubtobigqueryoperator","title":"PubsubToBigqueryOperator","text":"<p>source</p> <p>Operator for transferring messages from Pub/Sub to BigQuery.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#prepare_row","title":".prepare_row","text":"<p>source</p> <pre><code>.prepare_row(\n   row: Dict[str, Any], event_id: str, resource: str, extract_to_cols: bool,\n   keys_format: Optional[str]\n)\n</code></pre> <p>Prepares a single row for BigQuery insertion.</p> <p>Args</p> <ul> <li>row (Dict[str, Any]) : The row data.</li> <li>event_id (str) : The event ID.</li> <li>resource (str) : The resource name.</li> <li>extract_to_cols (bool) : Whether to extract to columns.</li> <li>keys_format (Optional[str]) : The format for keys.</li> </ul> <p>Returns</p> <ul> <li>The prepared row.</li> </ul>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#prepare_rows","title":".prepare_rows","text":"<p>source</p> <pre><code>.prepare_rows(\n   dto: BaseDto\n)\n</code></pre> <p>Prepares multiple rows for BigQuery insertion.</p> <p>Args</p> <ul> <li>dto (BaseDto) : The data transfer object containing the data.</li> </ul> <p>Returns</p> <ul> <li>The list of prepared rows.</li> </ul>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#format_key","title":".format_key","text":"<p>source</p> <pre><code>.format_key(\n   key: str\n)\n</code></pre> <p>Formats a key by removing invalid characters.</p> <p>Args</p> <ul> <li>key (str) : The key to format.</li> </ul> <p>Returns</p> <ul> <li>str  : The formatted key.</li> </ul>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#execute_1","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: Dict[str, Any], topic: str\n)\n</code></pre> <p>Executes the transfer from Pub/Sub to BigQuery.</p> <p>Args</p> <ul> <li>data (Dict[str, Any]) : The data containing message information.</li> <li>topic (str) : The Pub/Sub topic.</li> </ul>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#camel_to_snake","title":".camel_to_snake","text":"<p>source</p> <pre><code>.camel_to_snake(\n   s: str\n)\n</code></pre> <p>Converts a camelCase string to snake_case.</p> <p>Args</p> <ul> <li>s (str) : The camelCase string.</li> </ul> <p>Returns</p> <ul> <li>str  : The converted snake_case string.</li> </ul>"},{"location":"packages/airless-google-cloud-bigquery/airless/google/cloud/bigquery/operator/bigquery/#init_1","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the PubsubToBigqueryOperator.</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/base/","title":"Base","text":""},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/base/#googlebasefileoperator","title":"GoogleBaseFileOperator","text":"<p>source</p> <p>Base operator for file operations in Google Cloud.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/base/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleBaseFileOperator.</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/base/#googlebaseeventoperator","title":"GoogleBaseEventOperator","text":"<p>source</p> <p>Base operator for event operations in Google Cloud.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/base/#init_1","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleBaseEventOperator.</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/delay/","title":"Delay","text":""},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/delay/#googledelayoperator","title":"GoogleDelayOperator","text":"<p>source</p> <p>Operator that adds a delay to the pipeline.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/delay/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleDelayOperator.</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/error/","title":"Error","text":""},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/error/#googleerrorreprocessoperator","title":"GoogleErrorReprocessOperator","text":"<p>source</p> <p>Operator for reprocessing errors in Google Cloud.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/error/#prepare_row","title":".prepare_row","text":"<p>source</p> <pre><code>.prepare_row(\n   row: Dict[str, Any], message_id: Optional[str], origin: Optional[str]\n)\n</code></pre> <p>Prepares a row for insertion.</p> <p>Args</p> <ul> <li>row (Dict[str, Any]) : The row data.</li> <li>message_id (Optional[str]) : The message ID.</li> <li>origin (Optional[str]) : The origin of the message.</li> </ul> <p>Returns</p> <ul> <li>The prepared row.</li> </ul>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/error/#prepare_rows","title":".prepare_rows","text":"<p>source</p> <pre><code>.prepare_rows(\n   data: Any, message_id: Optional[str], origin: Optional[str]\n)\n</code></pre> <p>Prepares multiple rows for insertion.</p> <p>Args</p> <ul> <li>data (Any) : The data to prepare.</li> <li>message_id (Optional[str]) : The message ID.</li> <li>origin (Optional[str]) : The origin of the message.</li> </ul> <p>Returns</p> <ul> <li>The list of prepared rows.</li> </ul>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/error/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: Dict[str, Any], topic: str\n)\n</code></pre> <p>Executes the error reprocessing logic.</p> <p>Args</p> <ul> <li>data (Dict[str, Any]) : The input data containing error information.</li> <li>topic (str) : The Pub/Sub topic to publish messages to.</li> </ul>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/error/#notify_email","title":".notify_email","text":"<p>source</p> <pre><code>.notify_email(\n   origin: str, message_id: str, data: Dict[str, Any]\n)\n</code></pre> <p>Sends a notification email.</p> <p>Args</p> <ul> <li>origin (str) : The origin of the error.</li> <li>message_id (str) : The ID of the message.</li> <li>data (Dict[str, Any]) : The data related to the error.</li> </ul>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/error/#notify_slack","title":".notify_slack","text":"<p>source</p> <pre><code>.notify_slack(\n   origin: str, message_id: str, data: Dict[str, Any]\n)\n</code></pre> <p>Sends a notification to Slack.</p> <p>Args</p> <ul> <li>origin (str) : The origin of the error.</li> <li>message_id (str) : The ID of the message.</li> <li>data (Dict[str, Any]) : The data related to the error.</li> </ul>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/error/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleErrorReprocessOperator.</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/redirect/","title":"Redirect","text":""},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/redirect/#googleredirectoperator","title":"GoogleRedirectOperator","text":"<p>source</p> <p>Operator that receives one event from a pubsub topic and publish multiple messages to another topic.</p> <p>It can receive 4 parameters: project: the project where the destination pubsub is hosted topic: the pubsub topic it must publish the newly generated messages messages: a list of messages to publish the topic params: a list of dicts containing a key and a list of values</p> <p>The output messages will be the product of messages and every param values list</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/core/operator/redirect/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/pubsub/hook/pubsub/","title":"Pubsub","text":""},{"location":"packages/airless-google-cloud-core/airless/google/cloud/pubsub/hook/pubsub/#googlepubsubhook","title":"GooglePubsubHook","text":"<p>source</p> <p>Hook for interacting with Google Pub/Sub.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/pubsub/hook/pubsub/#publish","title":".publish","text":"<p>source</p> <pre><code>.publish(\n   project: str, topic: str, data: Any\n)\n</code></pre> <p>Publishes a message to a specified Pub/Sub topic.</p> <p>Args</p> <ul> <li>project (str) : The GCP project ID.</li> <li>topic (str) : The Pub/Sub topic name.</li> <li>data (Any) : The data to publish.</li> </ul> <p>Returns</p> <ul> <li>str  : A confirmation message.</li> </ul>"},{"location":"packages/airless-google-cloud-core/airless/google/cloud/pubsub/hook/pubsub/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GooglePubsubHook.</p>"},{"location":"packages/airless-google-cloud-secret-manager/airless/google/cloud/secret_manager/hook/secret_manager/","title":"Secret manager","text":""},{"location":"packages/airless-google-cloud-secret-manager/airless/google/cloud/secret_manager/hook/secret_manager/#googlesecretmanagerhook","title":"GoogleSecretManagerHook","text":"<p>source</p> <p>Hook for interacting with Google Secret Manager.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-secret-manager/airless/google/cloud/secret_manager/hook/secret_manager/#add_secret_version","title":".add_secret_version","text":"<p>source</p> <pre><code>.add_secret_version(\n   project: str, id: str, value: Any\n)\n</code></pre> <p>Adds a new version to a secret.</p> <p>Args</p> <ul> <li>project (str) : The project ID.</li> <li>id (str) : The secret ID.</li> <li>value (Any) : The value to store in the secret.</li> </ul> <p>Returns</p> <ul> <li>Any  : The response from the secret manager.</li> </ul>"},{"location":"packages/airless-google-cloud-secret-manager/airless/google/cloud/secret_manager/hook/secret_manager/#get_secret","title":".get_secret","text":"<p>source</p> <pre><code>.get_secret(\n   project: str, id: str, parse_json: bool = False\n)\n</code></pre> <p>Retrieves the latest version of a secret.</p> <p>Args</p> <ul> <li>project (str) : The project ID.</li> <li>id (str) : The secret ID.</li> <li>parse_json (bool, optional) : Whether to parse the secret as JSON. Defaults to False.</li> </ul> <p>Returns</p> <ul> <li>Any  : The secret value, parsed if requested.</li> </ul>"},{"location":"packages/airless-google-cloud-secret-manager/airless/google/cloud/secret_manager/hook/secret_manager/#list_secrets","title":".list_secrets","text":"<p>source</p> <pre><code>.list_secrets()\n</code></pre> <p>Lists all secrets in the project.</p> <p>Returns</p> <ul> <li>A list of secret names.</li> </ul>"},{"location":"packages/airless-google-cloud-secret-manager/airless/google/cloud/secret_manager/hook/secret_manager/#list_secret_versions","title":".list_secret_versions","text":"<p>source</p> <pre><code>.list_secret_versions(\n   secret_name: str, filter: str = 'state: (ENABLEDORDISABLED)'\n)\n</code></pre> <p>Lists all versions of a specified secret.</p> <p>Args</p> <ul> <li>secret_name (str) : The name of the secret.</li> <li>filter (str, optional) : The filter for the versions. Defaults to 'state:(ENABLED OR DISABLED)'.</li> </ul> <p>Returns</p> <ul> <li>A list of secret version names.</li> </ul>"},{"location":"packages/airless-google-cloud-secret-manager/airless/google/cloud/secret_manager/hook/secret_manager/#destroy_secret_version","title":".destroy_secret_version","text":"<p>source</p> <pre><code>.destroy_secret_version(\n   secret_name: str, version: str\n)\n</code></pre> <p>Destroys a specific version of a secret.</p> <p>Args</p> <ul> <li>secret_name (str) : The name of the secret.</li> <li>version (str) : The version of the secret to destroy.</li> </ul> <p>Returns</p> <ul> <li>str  : The name of the destroyed version.</li> </ul>"},{"location":"packages/airless-google-cloud-secret-manager/airless/google/cloud/secret_manager/hook/secret_manager/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleSecretManagerHook.</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/","title":"Storage","text":""},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#gcshook","title":"GcsHook","text":"<p>source</p> <p>Hook for interacting with Google Cloud Storage.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#list","title":".list","text":"<p>source</p> <pre><code>.list(\n   bucket_name: str, prefix: Optional[str] = None\n)\n</code></pre> <p>Lists blobs in a GCS bucket.</p> <p>Args</p> <ul> <li>bucket_name (str) : The name of the GCS bucket.</li> <li>prefix (Optional[str]) : The prefix to filter blobs. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>The list of blobs.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#read_as_bytes","title":".read_as_bytes","text":"<p>source</p> <pre><code>.read_as_bytes(\n   bucket: str, filepath: str\n)\n</code></pre> <p>Reads a file from GCS as bytes.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> </ul> <p>Returns</p> <ul> <li>bytes  : The content of the file as bytes.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#upload_from_memory","title":".upload_from_memory","text":"<p>source</p> <pre><code>.upload_from_memory(\n   data: Any, bucket: str, directory: str, filename: str, **kwargs: Any\n)\n</code></pre> <p>Uploads data from memory to GCS.</p> <p>Args</p> <ul> <li>data (Any) : The data to upload.</li> <li>bucket (str) : The name of the GCS bucket.</li> <li>directory (str) : The directory within the bucket.</li> <li>filename (str) : The name of the file to create.</li> </ul> <p>Kwargs:     mode (str, optional): The mode for opening the file. Defaults to 'w'.</p> <p>Returns</p> <ul> <li>str  : The path to the uploaded file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GcsHook.</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#read_json","title":".read_json","text":"<p>source</p> <pre><code>.read_json(\n   bucket: str, filepath: str, encoding: Optional[str] = None\n)\n</code></pre> <p>Reads a JSON file from GCS.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> <li>encoding (Optional[str]) : The encoding to use. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>Any  : The content of the JSON file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#read_ndjson","title":".read_ndjson","text":"<p>source</p> <pre><code>.read_ndjson(\n   bucket: str, filepath: str, encoding: Optional[str] = None\n)\n</code></pre> <p>Reads an NDJSON file from GCS.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> <li>encoding (Optional[str]) : The encoding to use. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>The content of the NDJSON file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#check_existance","title":".check_existance","text":"<p>source</p> <pre><code>.check_existance(\n   bucket: str, filepath: str\n)\n</code></pre> <p>Checks if a file exists in GCS.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> </ul> <p>Returns</p> <ul> <li>bool  : True if the file exists, False otherwise.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#move","title":".move","text":"<p>source</p> <pre><code>.move(\n   from_bucket: str, from_prefix: str, to_bucket: str, to_directory: str,\n   rewrite: bool\n)\n</code></pre> <p>Moves files from one GCS location to another.</p> <p>Args</p> <ul> <li>from_bucket (str) : The source bucket.</li> <li>from_prefix (str) : The source prefix.</li> <li>to_bucket (str) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> <li>rewrite (bool) : Whether to overwrite existing files.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#upload_folder","title":".upload_folder","text":"<p>source</p> <pre><code>.upload_folder(\n   local_path: str, bucket: str, gcs_path: str\n)\n</code></pre> <p>Uploads a folder to GCS.</p> <p>Args</p> <ul> <li>local_path (str) : The local folder path.</li> <li>bucket (str) : The name of the GCS bucket.</li> <li>gcs_path (str) : The GCS path to upload to.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#files_to_blobs","title":".files_to_blobs","text":"<p>source</p> <pre><code>.files_to_blobs(\n   bucket: storage.Bucket, files: List[str]\n)\n</code></pre> <p>Converts a list of file names to blobs.</p> <p>Args</p> <ul> <li>bucket (storage.Bucket) : The GCS bucket.</li> <li>files (List[str]) : The list of file names.</li> </ul> <p>Returns</p> <ul> <li>The list of blobs.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#upload_parquet_from_memory","title":".upload_parquet_from_memory","text":"<p>source</p> <pre><code>.upload_parquet_from_memory(\n   data: Any, bucket: str, directory: str, filename: str, **kwargs: Any\n)\n</code></pre> <p>Uploads Parquet data from memory to GCS.</p> <p>Args</p> <ul> <li>data (Any) : The data to upload.</li> <li>bucket (str) : The name of the GCS bucket.</li> <li>directory (str) : The directory within the bucket.</li> <li>filename (str) : The name of the Parquet file to create.</li> </ul> <p>Kwargs:     add_timestamp (bool, optional): If True, adds a timestamp to the filename. Defaults to True.</p> <p>Returns</p> <ul> <li>str  : The path to the uploaded Parquet file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#rewrite_blobs","title":".rewrite_blobs","text":"<p>source</p> <pre><code>.rewrite_blobs(\n   blobs: List[storage.Blob], to_bucket: storage.Bucket, to_directory: str\n)\n</code></pre> <p>Rewrites blobs in the destination bucket.</p> <p>Args</p> <ul> <li>blobs (List[storage.Blob]) : The list of blobs to rewrite.</li> <li>to_bucket (storage.Bucket) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#upload","title":".upload","text":"<p>source</p> <pre><code>.upload(\n   local_filepath: str, bucket_name: str, directory: str\n)\n</code></pre> <p>Uploads a local file to GCS.</p> <p>Args</p> <ul> <li>local_filepath (str) : The path to the local file.</li> <li>bucket_name (str) : The name of the GCS bucket.</li> <li>directory (str) : The directory within the bucket.</li> </ul> <p>Returns</p> <ul> <li>str  : The path to the uploaded file in GCS.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#delete","title":".delete","text":"<p>source</p> <pre><code>.delete(\n   bucket_name: str, prefix: Optional[str] = None, files: Optional[List[str]] = None\n)\n</code></pre> <p>Deletes files from GCS.</p> <p>Args</p> <ul> <li>bucket_name (str) : The name of the GCS bucket.</li> <li>prefix (Optional[str]) : The prefix for files to delete. Defaults to None.</li> <li>files (Optional[List[str]]) : The list of specific files to delete. Defaults to None.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#copy_blobs","title":".copy_blobs","text":"<p>source</p> <pre><code>.copy_blobs(\n   bucket: storage.Bucket, blobs: List[storage.Blob], to_bucket: storage.Bucket,\n   to_directory: str\n)\n</code></pre> <p>Copies blobs from one bucket to another.</p> <p>Args</p> <ul> <li>bucket (storage.Bucket) : The source bucket.</li> <li>blobs (List[storage.Blob]) : The list of blobs to copy.</li> <li>to_bucket (storage.Bucket) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#delete_blobs","title":".delete_blobs","text":"<p>source</p> <pre><code>.delete_blobs(\n   blobs: List[storage.Blob]\n)\n</code></pre> <p>Deletes a list of blobs.</p> <p>Args</p> <ul> <li>blobs (List[storage.Blob]) : The list of blobs to delete.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#move_blobs","title":".move_blobs","text":"<p>source</p> <pre><code>.move_blobs(\n   bucket: storage.Bucket, blobs: List[storage.Blob], to_bucket: storage.Bucket,\n   to_directory: str, rewrite: bool\n)\n</code></pre> <p>Moves blobs from one bucket to another.</p> <p>Args</p> <ul> <li>bucket (storage.Bucket) : The source bucket.</li> <li>blobs (List[storage.Blob]) : The list of blobs to move.</li> <li>to_bucket (storage.Bucket) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> <li>rewrite (bool) : Whether to overwrite existing files.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#download","title":".download","text":"<p>source</p> <pre><code>.download(\n   bucket: str, filepath: str, target_filepath: Optional[str] = None\n)\n</code></pre> <p>Downloads a file from GCS.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> <li>target_filepath (Optional[str]) : The target file path. Defaults to None.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#move_files","title":".move_files","text":"<p>source</p> <pre><code>.move_files(\n   from_bucket: str, files: List[str], to_bucket: str, to_directory: str,\n   rewrite: bool\n)\n</code></pre> <p>Moves specified files from one GCS location to another.</p> <p>Args</p> <ul> <li>from_bucket (str) : The source bucket.</li> <li>files (List[str]) : The list of files to move.</li> <li>to_bucket (str) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> <li>rewrite (bool) : Whether to overwrite existing files.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#build_filepath","title":".build_filepath","text":"<p>source</p> <pre><code>.build_filepath(\n   bucket: str, filepath: str\n)\n</code></pre> <p>Builds the full GCS file path.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> </ul> <p>Returns</p> <ul> <li>str  : The full GCS file path.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#read_as_string","title":".read_as_string","text":"<p>source</p> <pre><code>.read_as_string(\n   bucket: str, filepath: str, encoding: Optional[str] = None\n)\n</code></pre> <p>Reads a file from GCS as a string.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> <li>encoding (Optional[str]) : The encoding to use. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>str  : The content of the file as a string.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#gcsdatalakehook","title":"GcsDatalakeHook","text":"<p>source</p> <p>Hook for interacting with GCS Datalake.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#prepare_row","title":".prepare_row","text":"<p>source</p> <pre><code>.prepare_row(\n   row: Any, metadata: Dict[str, Any], now: datetime\n)\n</code></pre> <p>Prepares a row for insertion into the datalake.</p> <p>Args</p> <ul> <li>row (Any) : The row data.</li> <li>metadata (Dict[str, Any]) : The metadata for the row.</li> <li>now (datetime) : The current timestamp.</li> </ul> <p>Returns</p> <ul> <li>The prepared row.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#prepare_rows","title":".prepare_rows","text":"<p>source</p> <pre><code>.prepare_rows(\n   data: Any, metadata: Dict[str, Any]\n)\n</code></pre> <p>Prepares multiple rows for insertion into the datalake.</p> <p>Args</p> <ul> <li>data (Any) : The data to prepare.</li> <li>metadata (Dict[str, Any]) : The metadata for the rows.</li> </ul> <p>Returns</p> <ul> <li>The prepared rows and the current timestamp.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#build_metadata","title":".build_metadata","text":"<p>source</p> <pre><code>.build_metadata(\n   message_id: Optional[int], origin: Optional[str]\n)\n</code></pre> <p>Builds metadata for the data being sent.</p> <p>Args</p> <ul> <li>message_id (Optional[int]) : The message ID.</li> <li>origin (Optional[str]) : The origin of the data.</li> </ul> <p>Returns</p> <ul> <li>The metadata dictionary.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#init_1","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GcsDatalakeHook.</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/hook/storage/#send_to_landing_zone","title":".send_to_landing_zone","text":"<p>source</p> <pre><code>.send_to_landing_zone(\n   data: Any, dataset: str, table: str, message_id: Optional[int],\n   origin: Optional[str], time_partition: bool = False\n)\n</code></pre> <p>Sends data to the landing zone in GCS.</p> <p>Args</p> <ul> <li>data (Any) : The data to send.</li> <li>dataset (str) : The dataset name.</li> <li>table (str) : The table name.</li> <li>message_id (Optional[int]) : The message ID.</li> <li>origin (Optional[str]) : The origin of the data.</li> <li>time_partition (bool, optional) : Whether to use time partitioning. Defaults to False.</li> </ul> <p>Returns</p> <ul> <li>The path to the uploaded file or None.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/file/","title":"File","text":""},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/file/#fileurltogcsoperator","title":"FileUrlToGcsOperator","text":"<p>source</p> <p>Operator for transferring files from a URL to GCS.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/file/#move_to_destinations","title":".move_to_destinations","text":"<p>source</p> <pre><code>.move_to_destinations(\n   local_filepath: str, destination: Union[Dict[str, Any], List[Dict[str, Any]]]\n)\n</code></pre> <p>Moves the downloaded file to the specified destinations.</p> <p>Args</p> <ul> <li>local_filepath (str) : The local file path.</li> <li>destination (Union[Dict[str, Any], List[Dict[str, Any]]]) : The destination(s) for the file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/file/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the FileUrlToGcsOperator.</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/file/#remove_null_byte","title":".remove_null_byte","text":"<p>source</p> <pre><code>.remove_null_byte(\n   local_filepath: str\n)\n</code></pre> <p>Removes null bytes from the specified file.</p> <p>Args</p> <ul> <li>local_filepath (str) : The local file path.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/file/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: Dict[str, Any], topic: str\n)\n</code></pre> <p>Executes the file transfer from URL to GCS.</p> <p>Args</p> <ul> <li>data (Dict[str, Any]) : The data containing URL and GCS information.</li> <li>topic (str) : The Pub/Sub topic.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/ftp/","title":"Ftp","text":""},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/ftp/#ftptogcsoperator","title":"FtpToGcsOperator","text":"<p>source</p> <p>Operator for transferring files from FTP to GCS.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/ftp/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the FtpToGcsOperator.</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/ftp/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: Dict[str, str], topic: str\n)\n</code></pre> <p>Executes the FTP to GCS transfer.</p> <p>Args</p> <ul> <li>data (Dict[str, str]) : The data containing FTP and GCS information.</li> <li>topic (str) : The Pub/Sub topic.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/","title":"Storage","text":""},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#gcshook","title":"GcsHook","text":"<p>source</p> <p>Hook for interacting with Google Cloud Storage.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#list","title":".list","text":"<p>source</p> <pre><code>.list(\n   bucket_name: str, prefix: Optional[str] = None\n)\n</code></pre> <p>Lists blobs in a GCS bucket.</p> <p>Args</p> <ul> <li>bucket_name (str) : The name of the GCS bucket.</li> <li>prefix (Optional[str]) : The prefix to filter blobs. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>The list of blobs.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#read_as_bytes","title":".read_as_bytes","text":"<p>source</p> <pre><code>.read_as_bytes(\n   bucket: str, filepath: str\n)\n</code></pre> <p>Reads a file from GCS as bytes.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> </ul> <p>Returns</p> <ul> <li>bytes  : The content of the file as bytes.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#upload_from_memory","title":".upload_from_memory","text":"<p>source</p> <pre><code>.upload_from_memory(\n   data: Any, bucket: str, directory: str, filename: str, **kwargs: Any\n)\n</code></pre> <p>Uploads data from memory to GCS.</p> <p>Args</p> <ul> <li>data (Any) : The data to upload.</li> <li>bucket (str) : The name of the GCS bucket.</li> <li>directory (str) : The directory within the bucket.</li> <li>filename (str) : The name of the file to create.</li> </ul> <p>Kwargs:     mode (str, optional): The mode for opening the file. Defaults to 'w'.</p> <p>Returns</p> <ul> <li>str  : The path to the uploaded file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GcsHook.</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#read_json","title":".read_json","text":"<p>source</p> <pre><code>.read_json(\n   bucket: str, filepath: str, encoding: Optional[str] = None\n)\n</code></pre> <p>Reads a JSON file from GCS.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> <li>encoding (Optional[str]) : The encoding to use. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>Any  : The content of the JSON file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#read_ndjson","title":".read_ndjson","text":"<p>source</p> <pre><code>.read_ndjson(\n   bucket: str, filepath: str, encoding: Optional[str] = None\n)\n</code></pre> <p>Reads an NDJSON file from GCS.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> <li>encoding (Optional[str]) : The encoding to use. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>The content of the NDJSON file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#check_existance","title":".check_existance","text":"<p>source</p> <pre><code>.check_existance(\n   bucket: str, filepath: str\n)\n</code></pre> <p>Checks if a file exists in GCS.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> </ul> <p>Returns</p> <ul> <li>bool  : True if the file exists, False otherwise.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#move","title":".move","text":"<p>source</p> <pre><code>.move(\n   from_bucket: str, from_prefix: str, to_bucket: str, to_directory: str,\n   rewrite: bool\n)\n</code></pre> <p>Moves files from one GCS location to another.</p> <p>Args</p> <ul> <li>from_bucket (str) : The source bucket.</li> <li>from_prefix (str) : The source prefix.</li> <li>to_bucket (str) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> <li>rewrite (bool) : Whether to overwrite existing files.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#upload_folder","title":".upload_folder","text":"<p>source</p> <pre><code>.upload_folder(\n   local_path: str, bucket: str, gcs_path: str\n)\n</code></pre> <p>Uploads a folder to GCS.</p> <p>Args</p> <ul> <li>local_path (str) : The local folder path.</li> <li>bucket (str) : The name of the GCS bucket.</li> <li>gcs_path (str) : The GCS path to upload to.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#files_to_blobs","title":".files_to_blobs","text":"<p>source</p> <pre><code>.files_to_blobs(\n   bucket: storage.Bucket, files: List[str]\n)\n</code></pre> <p>Converts a list of file names to blobs.</p> <p>Args</p> <ul> <li>bucket (storage.Bucket) : The GCS bucket.</li> <li>files (List[str]) : The list of file names.</li> </ul> <p>Returns</p> <ul> <li>The list of blobs.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#upload_parquet_from_memory","title":".upload_parquet_from_memory","text":"<p>source</p> <pre><code>.upload_parquet_from_memory(\n   data: Any, bucket: str, directory: str, filename: str, **kwargs: Any\n)\n</code></pre> <p>Uploads Parquet data from memory to GCS.</p> <p>Args</p> <ul> <li>data (Any) : The data to upload.</li> <li>bucket (str) : The name of the GCS bucket.</li> <li>directory (str) : The directory within the bucket.</li> <li>filename (str) : The name of the Parquet file to create.</li> </ul> <p>Kwargs:     add_timestamp (bool, optional): If True, adds a timestamp to the filename. Defaults to True.</p> <p>Returns</p> <ul> <li>str  : The path to the uploaded Parquet file.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#rewrite_blobs","title":".rewrite_blobs","text":"<p>source</p> <pre><code>.rewrite_blobs(\n   blobs: List[storage.Blob], to_bucket: storage.Bucket, to_directory: str\n)\n</code></pre> <p>Rewrites blobs in the destination bucket.</p> <p>Args</p> <ul> <li>blobs (List[storage.Blob]) : The list of blobs to rewrite.</li> <li>to_bucket (storage.Bucket) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#upload","title":".upload","text":"<p>source</p> <pre><code>.upload(\n   local_filepath: str, bucket_name: str, directory: str\n)\n</code></pre> <p>Uploads a local file to GCS.</p> <p>Args</p> <ul> <li>local_filepath (str) : The path to the local file.</li> <li>bucket_name (str) : The name of the GCS bucket.</li> <li>directory (str) : The directory within the bucket.</li> </ul> <p>Returns</p> <ul> <li>str  : The path to the uploaded file in GCS.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#delete","title":".delete","text":"<p>source</p> <pre><code>.delete(\n   bucket_name: str, prefix: Optional[str] = None, files: Optional[List[str]] = None\n)\n</code></pre> <p>Deletes files from GCS.</p> <p>Args</p> <ul> <li>bucket_name (str) : The name of the GCS bucket.</li> <li>prefix (Optional[str]) : The prefix for files to delete. Defaults to None.</li> <li>files (Optional[List[str]]) : The list of specific files to delete. Defaults to None.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#copy_blobs","title":".copy_blobs","text":"<p>source</p> <pre><code>.copy_blobs(\n   bucket: storage.Bucket, blobs: List[storage.Blob], to_bucket: storage.Bucket,\n   to_directory: str\n)\n</code></pre> <p>Copies blobs from one bucket to another.</p> <p>Args</p> <ul> <li>bucket (storage.Bucket) : The source bucket.</li> <li>blobs (List[storage.Blob]) : The list of blobs to copy.</li> <li>to_bucket (storage.Bucket) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#delete_blobs","title":".delete_blobs","text":"<p>source</p> <pre><code>.delete_blobs(\n   blobs: List[storage.Blob]\n)\n</code></pre> <p>Deletes a list of blobs.</p> <p>Args</p> <ul> <li>blobs (List[storage.Blob]) : The list of blobs to delete.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#move_blobs","title":".move_blobs","text":"<p>source</p> <pre><code>.move_blobs(\n   bucket: storage.Bucket, blobs: List[storage.Blob], to_bucket: storage.Bucket,\n   to_directory: str, rewrite: bool\n)\n</code></pre> <p>Moves blobs from one bucket to another.</p> <p>Args</p> <ul> <li>bucket (storage.Bucket) : The source bucket.</li> <li>blobs (List[storage.Blob]) : The list of blobs to move.</li> <li>to_bucket (storage.Bucket) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> <li>rewrite (bool) : Whether to overwrite existing files.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#download","title":".download","text":"<p>source</p> <pre><code>.download(\n   bucket: str, filepath: str, target_filepath: Optional[str] = None\n)\n</code></pre> <p>Downloads a file from GCS.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> <li>target_filepath (Optional[str]) : The target file path. Defaults to None.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#move_files","title":".move_files","text":"<p>source</p> <pre><code>.move_files(\n   from_bucket: str, files: List[str], to_bucket: str, to_directory: str,\n   rewrite: bool\n)\n</code></pre> <p>Moves specified files from one GCS location to another.</p> <p>Args</p> <ul> <li>from_bucket (str) : The source bucket.</li> <li>files (List[str]) : The list of files to move.</li> <li>to_bucket (str) : The destination bucket.</li> <li>to_directory (str) : The destination directory.</li> <li>rewrite (bool) : Whether to overwrite existing files.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#build_filepath","title":".build_filepath","text":"<p>source</p> <pre><code>.build_filepath(\n   bucket: str, filepath: str\n)\n</code></pre> <p>Builds the full GCS file path.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> </ul> <p>Returns</p> <ul> <li>str  : The full GCS file path.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#read_as_string","title":".read_as_string","text":"<p>source</p> <pre><code>.read_as_string(\n   bucket: str, filepath: str, encoding: Optional[str] = None\n)\n</code></pre> <p>Reads a file from GCS as a string.</p> <p>Args</p> <ul> <li>bucket (str) : The name of the GCS bucket.</li> <li>filepath (str) : The file path.</li> <li>encoding (Optional[str]) : The encoding to use. Defaults to None.</li> </ul> <p>Returns</p> <ul> <li>str  : The content of the file as a string.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#gcsdatalakehook","title":"GcsDatalakeHook","text":"<p>source</p> <p>Hook for interacting with GCS Datalake.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#prepare_row","title":".prepare_row","text":"<p>source</p> <pre><code>.prepare_row(\n   row: Any, metadata: Dict[str, Any], now: datetime\n)\n</code></pre> <p>Prepares a row for insertion into the datalake.</p> <p>Args</p> <ul> <li>row (Any) : The row data.</li> <li>metadata (Dict[str, Any]) : The metadata for the row.</li> <li>now (datetime) : The current timestamp.</li> </ul> <p>Returns</p> <ul> <li>The prepared row.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#prepare_rows","title":".prepare_rows","text":"<p>source</p> <pre><code>.prepare_rows(\n   data: Any, metadata: Dict[str, Any]\n)\n</code></pre> <p>Prepares multiple rows for insertion into the datalake.</p> <p>Args</p> <ul> <li>data (Any) : The data to prepare.</li> <li>metadata (Dict[str, Any]) : The metadata for the rows.</li> </ul> <p>Returns</p> <ul> <li>The prepared rows and the current timestamp.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#build_metadata","title":".build_metadata","text":"<p>source</p> <pre><code>.build_metadata(\n   message_id: Optional[int], origin: Optional[str]\n)\n</code></pre> <p>Builds metadata for the data being sent.</p> <p>Args</p> <ul> <li>message_id (Optional[int]) : The message ID.</li> <li>origin (Optional[str]) : The origin of the data.</li> </ul> <p>Returns</p> <ul> <li>The metadata dictionary.</li> </ul>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#init_1","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GcsDatalakeHook.</p>"},{"location":"packages/airless-google-cloud-storage/airless/google/cloud/storage/operator/storage/#send_to_landing_zone","title":".send_to_landing_zone","text":"<p>source</p> <pre><code>.send_to_landing_zone(\n   data: Any, dataset: str, table: str, message_id: Optional[int],\n   origin: Optional[str], time_partition: bool = False\n)\n</code></pre> <p>Sends data to the landing zone in GCS.</p> <p>Args</p> <ul> <li>data (Any) : The data to send.</li> <li>dataset (str) : The dataset name.</li> <li>table (str) : The table name.</li> <li>message_id (Optional[int]) : The message ID.</li> <li>origin (Optional[str]) : The origin of the data.</li> <li>time_partition (bool, optional) : Whether to use time partitioning. Defaults to False.</li> </ul> <p>Returns</p> <ul> <li>The path to the uploaded file or None.</li> </ul>"},{"location":"packages/airless-google-cloud-vertexai/airless/google/cloud/vertexai/hook/generative_model/","title":"Generative model","text":""},{"location":"packages/airless-google-cloud-vertexai/airless/google/cloud/vertexai/hook/generative_model/#generativemodelhook","title":"GenerativeModelHook","text":"<p>source</p> <pre><code>GenerativeModelHook(\n   model_name: str, **kwargs: Any\n)\n</code></pre> <p>Hook for interacting with Vertex AI Generative Models.</p> <p>Methods:</p>"},{"location":"packages/airless-google-cloud-vertexai/airless/google/cloud/vertexai/hook/generative_model/#init","title":".init","text":"<p>source</p> <pre><code>.__init__(\n   model_name: str, **kwargs: Any\n)\n</code></pre> <p>Initializes the GenerativeModelHook.</p> <p>Args</p> <ul> <li>model_name (str) : The name of the model to use.</li> <li>kwargs (Any) : Additional arguments for model initialization.</li> </ul>"},{"location":"packages/airless-google-cloud-vertexai/airless/google/cloud/vertexai/hook/generative_model/#generate_completion","title":".generate_completion","text":"<p>source</p> <pre><code>.generate_completion(\n   content: str, **kwargs: Any\n)\n</code></pre> <p>Generates a completion for the given content.</p> <p>Args</p> <ul> <li>content (str) : The content to generate a completion for.</li> <li>kwargs (Any) : Additional arguments for the generation.</li> </ul> <p>Returns</p> <ul> <li>Any  : The generated completion.</li> </ul>"},{"location":"packages/airless-pdf/airless/pdf/hook/pdf/","title":"Pdf","text":""},{"location":"packages/airless-pdf/airless/pdf/hook/pdf/#pdfhook","title":"PDFHook","text":"<p>source</p> <p>Hook for handling PDF operations.</p> <p>Methods:</p>"},{"location":"packages/airless-pdf/airless/pdf/hook/pdf/#chunk_in_pages","title":".chunk_in_pages","text":"<p>source</p> <pre><code>.chunk_in_pages(\n   filepath: str, pages_per_chunk: int\n)\n</code></pre> <p>Splits the PDF into chunks with a specified number of pages per chunk.</p> <p>Args</p> <ul> <li>filepath (str) : Path to the PDF file.</li> <li>pages_per_chunk (int) : Number of pages per chunk.</li> </ul> <p>Returns</p> <ul> <li>List of file paths to the chunked PDF files.</li> </ul>"},{"location":"packages/airless-pdf/airless/pdf/hook/pdf/#generate_page_screenshot","title":".generate_page_screenshot","text":"<p>source</p> <pre><code>.generate_page_screenshot(\n   filepath: str, dpi: int = 300, output_format: str = 'png'\n)\n</code></pre> <p>Converts each page of a PDF into an image.</p> <p>Args</p> <ul> <li>filepath (str) : The file path to the PDF.</li> <li>dpi (int, optional) : Dots per inch for the output image. Defaults to 300.</li> <li>output_format (str, optional) : The format of the output images (e.g., 'png', 'jpg'). Defaults to 'png'.</li> </ul> <p>Returns</p> <ul> <li>A list of file paths to the generated images.</li> </ul>"},{"location":"packages/airless-pdf/airless/pdf/hook/pdf/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the PDFHook.</p>"},{"location":"packages/airless-slack/airless/slack/hook/slack/","title":"Slack","text":""},{"location":"packages/airless-slack/airless/slack/hook/slack/#slackhook","title":"SlackHook","text":"<p>source</p> <p>Hook for interacting with Slack API.</p> <p>Methods:</p>"},{"location":"packages/airless-slack/airless/slack/hook/slack/#set_token","title":".set_token","text":"<p>source</p> <pre><code>.set_token(\n   token: str\n)\n</code></pre> <p>Sets the authorization token for the Slack API.</p> <p>Args</p> <ul> <li>token (str) : The authorization token.</li> </ul>"},{"location":"packages/airless-slack/airless/slack/hook/slack/#get_headers","title":".get_headers","text":"<p>source</p> <pre><code>.get_headers()\n</code></pre> <p>Gets the headers for the Slack API requests.</p> <p>Returns</p> <ul> <li>The headers including the authorization token.</li> </ul>"},{"location":"packages/airless-slack/airless/slack/hook/slack/#send","title":".send","text":"<p>source</p> <pre><code>.send(\n   channel: Optional[str] = None, message: Optional[str] = None,\n   blocks: Optional[List[Dict[str, Any]]] = None, thread_ts: Optional[str] = None,\n   reply_broadcast: bool = False, attachments: Optional[List[Dict[str, Any]]] = None,\n   response_url: Optional[str] = None, response_type: Optional[str] = None,\n   replace_original: Optional[bool] = None\n)\n</code></pre> <p>Sends a message to a Slack channel or a response URL.</p> <p>Args</p> <ul> <li>channel (Optional[str]) : The channel to send the message to.</li> <li>message (Optional[str]) : The message text.</li> <li>blocks (Optional[List[Dict[str, Any]]]) : The message blocks.</li> <li>thread_ts (Optional[str]) : The timestamp of the thread to reply to.</li> <li>reply_broadcast (bool) : Whether to broadcast the reply to the channel.</li> <li>attachments (Optional[List[Dict[str, Any]]]) : The message attachments.</li> <li>response_url (Optional[str]) : The response URL to send the message to.</li> <li>response_type (Optional[str]) : The response type.</li> <li>replace_original (Optional[bool]) : Whether to replace the original message.</li> </ul> <p>Returns</p> <ul> <li>The response from the Slack API.</li> </ul>"},{"location":"packages/airless-slack/airless/slack/hook/slack/#react","title":".react","text":"<p>source</p> <pre><code>.react(\n   channel: str, reaction: str, ts: str\n)\n</code></pre> <p>Adds a reaction to a Slack message.</p> <p>Args</p> <ul> <li>channel (str) : The channel of the message.</li> <li>reaction (str) : The reaction to add.</li> <li>ts (str) : The timestamp of the message.</li> </ul> <p>Returns</p> <ul> <li>The response from the Slack API.</li> </ul>"},{"location":"packages/airless-slack/airless/slack/hook/slack/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the SlackHook.</p>"},{"location":"packages/airless-slack/airless/slack/operator/slack/","title":"Slack","text":""},{"location":"packages/airless-slack/airless/slack/operator/slack/#slacksendoperator","title":"SlackSendOperator","text":"<p>source</p> <p>Operator for sending messages to Slack.</p> <p>Methods:</p>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#init","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the SlackSendOperator.</p>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#execute","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: Dict[str, Any], topic: str\n)\n</code></pre> <p>Executes the sending of messages to Slack.</p> <p>Args</p> <ul> <li>data (Dict[str, Any]) : The data containing message information.</li> <li>topic (str) : The Pub/Sub topic.</li> </ul>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#slackreactoperator","title":"SlackReactOperator","text":"<p>source</p> <p>Operator for reacting to Slack messages.</p> <p>Methods:</p>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#init_1","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the SlackReactOperator.</p>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#execute_1","title":".execute","text":"<p>source</p> <pre><code>.execute(\n   data: Dict[str, Any], topic: str\n)\n</code></pre> <p>Executes the reaction to a Slack message.</p> <p>Args</p> <ul> <li>data (Dict[str, Any]) : The data containing reaction information.</li> <li>topic (str) : The Pub/Sub topic.</li> </ul>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#googleslacksendoperator","title":"GoogleSlackSendOperator","text":"<p>source</p> <p>Slack operator using Google Secret Manager to get secrets.</p> <p>Methods:</p>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#init_2","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleSlackSendOperator.</p>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#googleslackreactoperator","title":"GoogleSlackReactOperator","text":"<p>source</p> <p>Slack operator using Google Secret Manager to get secrets.</p> <p>Methods:</p>"},{"location":"packages/airless-slack/airless/slack/operator/slack/#init_3","title":".init","text":"<p>source</p> <pre><code>.__init__()\n</code></pre> <p>Initializes the GoogleSlackReactOperator.</p>"}]}