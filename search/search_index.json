{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Airless","text":"<p>Airless is a package that aims to build a serverless and lightweight orchestration platform, creating workflows of multiple tasks being executed on serverless functions. It is build to be Cloud agnostic, so using any Cloud provider is possible</p> <ul> <li>Google Cloud Functions</li> <li>AWS Lambda</li> <li>Azure Functions</li> </ul>"},{"location":"#why-not-just-use-apache-airflow","title":"Why not just use Apache Airflow?","text":"<p>Airflow is the industry standard when we talk about job orchestration and worflow management. However, in some cases, we believe it may not be the best solution. I would like to highlight 3 main cases we face that Airflow struggles to handle.</p> <ul> <li>Serverless</li> </ul> <p>At the beginning of a project we want to avoid dealing with infrastructure since it demands time and it has a fixed cost to reserve an instance to run Airflow. Since we didn't have that many jobs, it didn't make sense to have an instance of Airflow up 24-7. </p> <p>When the project starts to get bigger and, if we use Airflow's instance to run the tasks, we start facing performance issues on the workflow.</p> <p>In order to avoid this problems we decided to build a 100% serverless platform.</p> <ul> <li>Parallel processing</li> </ul> <p>The main use case we designed Airless for is for data scrappers. The problem with data scrappers is that normally you want them to process a lot of tasks in parallel, for instance, first you want to fetch a website and collect all links in that page and send them forward for another task to be executed and then that task does the same and so on and so forth.</p> <p>Building this workflow that does not know before hand how many tasks are going to be executed is something hard be built on Airflow.</p> <ul> <li>Data sharing between tasks</li> </ul> <p>In order to built this massive parallel processing workflow that we explained on the previous topic, we need to be able to dynamically create and send data to the next task. So use the data from the first task as a trigger and an input data for the next tasks. </p>"},{"location":"#architectural-decisions","title":"Architectural Decisions","text":"<ul> <li>Event-Driven Architecture: Utilizes queues to decouple event producers and consumers. Or use HTTP when need synchronous workflows</li> <li>Scalability: Serverless scale automatically based on the number of incoming messages.</li> </ul> <p>Data Flow - Trigger: A message is published to a queue topic or an HTTP request is made. - Cloud Function Invocation: The subscribed serverless service is triggered. - Operator Execution: Processes the message using Airless operators. - Data Storage/Forwarding: Uses hooks to store data in object stores, for example, or publish new messages to other queues.</p> <p>Performance Optimization - Efficient Data Handling: Use hooks to abstract and optimize interactions with external services. - Resource Management: Configure appropriate memory and timeout settings in your serverless service.</p> <p>Security - Least Privilege: Assign the minimum required permissions to service accounts. - Secret Management: Use secret manager to store sensitive information.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>Airless builts its workflows based on serverless functions, queues and schedulers. All of them serverless.</p> <ol> <li>Everything starts with the scheduler, which is able to publish a message to a queue with a cron scheduler</li> <li>When a message is published to the queue it can trigger a serverless function and get executed with that message as an input</li> <li>This serverless function is able to publish as many messages as it wants to as many queue topics as it wants</li> <li>Repeat from 2</li> </ol>"},{"location":"about/","title":"About","text":""},{"location":"about/#modular-architecture","title":"Modular Architecture","text":"<p>Why Modularize Airless?</p> <p>Airless\u2019s modular design reflects three guiding principles:</p> <ol> <li> <p>Minimal Footprint Start with only the code you need\u2014nothing more. By keeping the core package lean, you reduce memory usage, dependency conflicts and cold-start times in serverless environments.</p> </li> <li> <p>Pluggable Integrations Instead of a monolithic bundle, each integration lives in its own package. You opt-in to the features you require and avoid pulling in unused dependencies.</p> </li> <li> <p>Clear Separation of Concerns Core orchestration logic remains decoupled from cloud-provider or service-specific code. This isolation makes it easier to maintain, test and evolve each piece independently.</p> </li> </ol>"},{"location":"about/#core-package-airless-core","title":"Core Package: <code>airless-core</code>","text":"<p><code>airless-core</code> contains the fundamental building blocks for any workflow:</p> <ul> <li>Operator Abstractions   Define task units that consume events, execute logic, and emit output.  </li> <li>Hook Abstractions   Standard interfaces for interacting with sources and sinks.  </li> <li>Service Abstractions   Standard interfaces for interacting with third-party services like APIs, databases, etc.</li> <li>Utils   Utilities for common tasks.</li> </ul> <p>This package has zero opinion on which cloud provider or external service you use\u2014it only cares about the shape of events and tasks.</p>"},{"location":"about/#optional-packages","title":"Optional Packages","text":"<p>Airless offers a growing ecosystem of add-ons. Install only what you need for your project:</p> <ul> <li> <p><code>airless-captcha</code>   Package that integrates CAPTCHA solving services (e.g. reCAPTCHA or hCaptcha) as part of your data-collection pipelines.</p> </li> <li> <p><code>airless-email</code>   Package that sends emails from within your tasks, with many options to support.</p> </li> <li> <p><code>airless-google-cloud-core</code>   Foundation for all Google Cloud extends <code>airless-core</code> abstractions to create classes that can run and interact with Google Cloud Infrastructure.</p> </li> <li> <p><code>airless-google-cloud-storage</code>   Read/write blobs to Google Cloud Storage buckets.</p> </li> <li> <p><code>airless-google-cloud-secret-manager</code>   Retrieve secrets (API keys, credentials) from Secret Manager at runtime.</p> </li> <li> <p><code>airless-google-cloud-bigquery</code>   Load, query or stream data into BigQuery tables as part of your workflows.</p> </li> <li> <p><code>airless-google-cloud-vertexai</code>   Submit jobs or online predictions to Vertex AI models within your pipelines.</p> </li> <li> <p><code>airless-pdf</code>   Generate, merge or manipulate PDF documents on the fly.</p> </li> <li> <p><code>airless-slack</code>   Post messages, alerts or interactive dialogs to Slack channels and users.</p> </li> </ul> <p>Each optional package extends the core operator/hook abstractions, so you can mix and match services to build precisely the workflow you need\u2014no more, no less.</p>"},{"location":"infrastucture/","title":"Airless Runtime Infrastructure","text":"<p>Airless is a serverless orchestration framework designed for modular, event-driven workflows. To ensure seamless operation and interoperability between tasks, Airless requires a minimal set of foundational functions. These shared functions handle common concerns such as error handling, retries, delays, and notifications\u2014enabling developers to focus on business logic while maintaining observability and resilience.</p> <p>Note</p> <p>Each function lives in its own deployment unit (e.g. separate Cloud Run Function or AWS Lambda). This isolation ensures low memory footprint, faster cold starts, and independent scaling.</p>"},{"location":"infrastucture/#core-runtime-functions","title":"\ud83e\uddf1 Core Runtime Functions","text":"<p>Tip</p> <ul> <li>Deploy all functions using a infrastructure as code like Terraform or Pulumi.</li> </ul>"},{"location":"infrastucture/#error-function","title":"Error Function","text":"<ul> <li>Objective: Centralize failure handling so that any downstream error is captured, logged, and retried without losing the original event.</li> </ul>"},{"location":"infrastucture/#delay-function","title":"Delay Function","text":"<ul> <li>Objective: Decouple time-based waiting from business logic by offloading \u201csleep\u201d or cooldown periods to a dedicated function.</li> </ul>"},{"location":"infrastucture/#redirect-function","title":"Redirect Function","text":"<ul> <li>Objective: Enable branching and parallel workflows by duplicating incoming messages and forwarding them to multiple topics.</li> </ul>"},{"location":"infrastucture/#email-notification","title":"Email Notification","text":"<ul> <li>Objective: Decouple email alerting from core tasks by providing a standalone function that handles all SMTP interactions.</li> </ul>"},{"location":"infrastucture/#slack-notification","title":"Slack Notification","text":"<ul> <li>Objective: Provide real-time, chat-based alerts by centralizing Slack integration into one function.</li> </ul>"},{"location":"installation/","title":"Installing Airless","text":""},{"location":"installation/#using-uv","title":"Using uv","text":""},{"location":"installation/#create-uv-environment","title":"Create uv environment","text":"<p>We recommend creating an uv environment first:</p> <pre><code>uv init --bare --no-workspace\n</code></pre>"},{"location":"installation/#install-airless-core","title":"Install airless-core","text":"<p>Now, add airless-core to your environment, that is the main package:</p> <pre><code>uv add airless-core\n</code></pre>"},{"location":"installation/#using-pip-and-venv","title":"Using pip and venv","text":""},{"location":"installation/#create-activate-virtual-environment","title":"Create &amp; activate virtual environment","text":"<p>We recommend creating a virtual Python environment using venv:</p> <pre><code>python -m venv .venv\n</code></pre> <p>Now, you can activate the virtual environment using the appropriate command for your operating system and environment:</p> <pre><code># Mac / Linux\nsource .venv/bin/activate\n\n# Windows CMD:\n.venv\\Scripts\\activate.bat\n\n# Windows PowerShell:\n.venv\\Scripts\\Activate.ps1\n</code></pre>"},{"location":"installation/#install-airless-core_1","title":"Install airless-core","text":"<pre><code>pip install airless-core\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Try creating your first workflow with the Quickstart.</p>"},{"location":"api/airless-captcha/providers/","title":"providers","text":""},{"location":"api/airless-captcha/providers/#airless.captcha.providers","title":"<code>providers</code>","text":""},{"location":"api/airless-captcha/providers/#airless.captcha.providers.__all__","title":"<code>__all__ = ['Solver2CaptchaService']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-captcha/providers/#airless.captcha.providers.Solver2CaptchaService","title":"<code>Solver2CaptchaService</code>","text":"<p>               Bases: <code>CaptchaService</code></p> <p>Service for solving captchas using 2Captcha.</p>"},{"location":"api/airless-captcha/providers/#airless.captcha.providers.Solver2CaptchaService.__init__","title":"<code>__init__(credentials: dict) -&gt; None</code>","text":"<p>Initializes the Solver2CaptchaService.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>dict</code> <p>The credentials for the 2Captcha API.</p> required"},{"location":"api/airless-captcha/providers/#airless.captcha.providers.Solver2CaptchaService.report_bad_captcha","title":"<code>report_bad_captcha() -&gt; None</code>","text":"<p>Reports a captcha as unsolvable.</p>"},{"location":"api/airless-captcha/providers/#airless.captcha.providers.Solver2CaptchaService.report_good_captcha","title":"<code>report_good_captcha() -&gt; None</code>","text":"<p>Reports a captcha as solved successfully.</p>"},{"location":"api/airless-captcha/providers/#airless.captcha.providers.Solver2CaptchaService.solve","title":"<code>solve(version: str, page_url: str, google_key: str, action: str = 'verify') -&gt; str</code>","text":"<p>Solves a captcha using the specified version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>The version of the captcha (e.g., 'v2' or 'v3').</p> required <code>page_url</code> <code>str</code> <p>The URL of the page with the captcha.</p> required <code>google_key</code> <code>str</code> <p>The Google reCAPTCHA key.</p> required <code>action</code> <code>str</code> <p>The action to perform. Defaults to 'verify'.</p> <code>'verify'</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the captcha version is not implemented or if solving fails.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The solution to the captcha.</p>"},{"location":"api/airless-core/hook/","title":"hook","text":""},{"location":"api/airless-core/hook/#airless.core.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-core/hook/#airless.core.hook.__all__","title":"<code>__all__ = ['BaseHook', 'DatalakeHook', 'EmailHook', 'FileHook', 'FtpHook', 'QueueHook', 'SecretManagerHook', 'LLMHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-core/hook/#airless.core.hook.BaseHook","title":"<code>BaseHook</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Base class for hooks in the system.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.BaseHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the BaseHook.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.DatalakeHook","title":"<code>DatalakeHook</code>","text":"<p>               Bases: <code>BaseHook</code></p> <p>DatalakeHook class is designer to write data to the datalake and must be implemented by a specific datalake vendor class</p> Inherits from <p>BaseHook: The base class for hooks in the airless framework.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.DatalakeHook.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the DatalakeHook.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.DatalakeHook.build_metadata","title":"<code>build_metadata(message_id: Optional[int], origin: Optional[str]) -&gt; Dict[str, Any]</code>","text":"<p>Builds metadata for the data being sent.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[int]</code> <p>The message ID.</p> required <code>origin</code> <code>Optional[str]</code> <p>The origin of the data.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The metadata dictionary.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.DatalakeHook.prepare_row","title":"<code>prepare_row(row: Any, metadata: Dict[str, Any], now: datetime) -&gt; Dict[str, Any]</code>","text":"<p>Prepares a row for insertion into the datalake.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Any</code> <p>The row data.</p> required <code>metadata</code> <code>Dict[str, Any]</code> <p>The metadata for the row.</p> required <code>now</code> <code>datetime</code> <p>The current timestamp.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The prepared row.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.DatalakeHook.prepare_rows","title":"<code>prepare_rows(data: Any, metadata: Dict[str, Any]) -&gt; Tuple[List[Dict[str, Any]], datetime]</code>","text":"<p>Prepares multiple rows for insertion into the datalake.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to prepare.</p> required <code>metadata</code> <code>Dict[str, Any]</code> <p>The metadata for the rows.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Dict[str, Any]], datetime]</code> <p>Tuple[List[Dict[str, Any]], datetime]: The prepared rows and the current timestamp.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.DatalakeHook.send_to_landing_zone","title":"<code>send_to_landing_zone(data: Any, dataset: str, table: str, message_id: Optional[int], origin: Optional[str], time_partition: bool = False) -&gt; Union[str, None]</code>","text":"<p>Sends data to the landing zone. This method must be implemented by the vendor specific class</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to send.</p> required <code>dataset</code> <code>str</code> <p>The dataset name.</p> required <code>table</code> <code>str</code> <p>The table name.</p> required <code>message_id</code> <code>Optional[int]</code> <p>The message ID.</p> required <code>origin</code> <code>Optional[str]</code> <p>The origin of the data.</p> required <code>time_partition</code> <code>bool</code> <p>Whether to use time partitioning. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>Union[str, None]: The path to the uploaded file or None.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.EmailHook","title":"<code>EmailHook</code>","text":"<p>               Bases: <code>BaseHook</code></p> <p>EmailHook class to build and send email messages.</p> <p>This class is responsible for constructing email messages that may  include attachments and other related information. However, the  sending functionality is not implemented.</p> Inherits from <p>BaseHook: The base class for hooks in the airless framework.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.EmailHook.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the EmailHook class.</p> <p>This constructor calls the superclass constructor.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.EmailHook.build_message","title":"<code>build_message(subject: str, content: str, recipients: list, sender: str, attachments: list = [], mime_type: str = 'plain') -&gt; Union[MIMEMultipart, MIMEText]</code>","text":"<p>Builds an email message with optional attachments.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject of the email.</p> required <code>content</code> <code>str</code> <p>The body content of the email.</p> required <code>recipients</code> <code>list</code> <p>A list of recipient email addresses.</p> required <code>sender</code> <code>str</code> <p>The email address of the sender.</p> required <code>attachments</code> <code>list</code> <p>A list of attachment dictionaries.  Each dictionary should contain 'name', 'content', and optionally 'type'.  Defaults to an empty list.</p> <code>[]</code> <code>mime_type</code> <code>str</code> <p>The MIME type of the email body content.  Defaults to 'plain'.</p> <code>'plain'</code> <p>Returns:</p> Type Description <code>Union[MIMEMultipart, MIMEText]</code> <p>Union[MIMEMultipart, MIMEText]: The constructed email message object.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.EmailHook.send","title":"<code>send(subject: str, content: str, recipients: list, sender: str, attachments: list, mime_type: str)</code>","text":"<p>Sends the constructed email message.</p> <p>This method is not implemented and will raise a NotImplementedError.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject of the email.</p> required <code>content</code> <code>str</code> <p>The body content of the email.</p> required <code>recipients</code> <code>list</code> <p>A list of recipient email addresses.</p> required <code>sender</code> <code>str</code> <p>The email address of the sender.</p> required <code>attachments</code> <code>list</code> <p>A list of attachment dictionaries.</p> required <code>mime_type</code> <code>str</code> <p>The MIME type of the email body content.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method has not been implemented.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook","title":"<code>FileHook</code>","text":"<p>               Bases: <code>BaseHook</code></p> <p>FileHook class for handling file operations.</p> <p>This class provides methods to write data to local files in various formats (JSON and NDJSON), download files, rename files, and list files in a directory.</p> Inherits from <p>BaseHook: The base class for hooks in the airless framework.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of the FileHook class.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook.download","title":"<code>download(url: str, headers: dict, timeout: int = 500, proxies: dict = None) -&gt; str</code>","text":"<p>Downloads a file from a given URL and saves it to a temporary path.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file to download.</p> required <code>headers</code> <code>dict</code> <p>The headers to include in the request.</p> required <code>timeout</code> <code>int</code> <p>The request timeout in seconds. Defaults to 500.</p> <code>500</code> <code>proxies</code> <code>dict</code> <p>Proxy settings for the request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The local filename where the downloaded file is saved.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook.extract_filename","title":"<code>extract_filename(filepath_or_url: str) -&gt; str</code>","text":"<p>Extracts the filename from a filepath or URL.</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_url</code> <code>str</code> <p>The original file path or URL.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted filename.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook.get_tmp_filepath","title":"<code>get_tmp_filepath(filepath_or_url: str, **kwargs) -&gt; str</code>","text":"<p>Generates a temporary file path based on the provided filepath or URL.</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_url</code> <code>str</code> <p>The original file path or URL from which the filename is extracted.</p> required Kwargs <p>add_timestamp (bool, optional):     If <code>True</code>, a timestamp and a UUID will be prefixed to the filename to ensure uniqueness.     Defaults to <code>True</code>.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The temporary file path.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook.list_files","title":"<code>list_files(folder: str) -&gt; list</code>","text":"<p>Lists all files in a specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder path to search for files.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of file paths found in the directory.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook.rename","title":"<code>rename(from_filename: str, to_filename: str) -&gt; str</code>","text":"<p>Renames a file from the original filename to the new filename.</p> <p>Parameters:</p> Name Type Description Default <code>from_filename</code> <code>str</code> <p>The original filename to rename.</p> required <code>to_filename</code> <code>str</code> <p>The new filename.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The new filename after renaming.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook.rename_files","title":"<code>rename_files(dir, prefix)</code>","text":"<p>Renames all files in a directory by prepending a prefix.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>The directory containing files to rename.</p> required <code>prefix</code> <code>str</code> <p>The prefix to prepend to each file name.</p> required"},{"location":"api/airless-core/hook/#airless.core.hook.FileHook.write","title":"<code>write(local_filepath: str, data: Any, **kwargs) -&gt; None</code>","text":"<p>Writes data to a local file with support for JSON and NDJSON formats.</p> <p>Parameters:</p> Name Type Description Default <code>local_filepath</code> <code>str</code> <p>The path to the local file where the data will be written.</p> required <code>data</code> <code>Any</code> <p>The data to write to the file. It can be a string, dictionary, list, or any other type that can be serialized to JSON or converted to a string.</p> required <p>Kwargs:     use_ndjson (bool):         If <code>True</code> and the data is a dictionary or list, the data will be         written in NDJSON format. Defaults to <code>False</code>.     mode (str):         The mode in which the file is opened. Common modes include:         - <code>'w'</code>: Write mode, which overwrites the file if it exists.         - <code>'wb'</code>: Write binary mode, which overwrites the file if it exists.         Defaults to <code>'w'</code>.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook","title":"<code>FtpHook</code>","text":"<p>               Bases: <code>FileHook</code></p> <p>FtpHook class for handling FTP file operations.</p> <p>This class extends FileHook with methods specific to FTP file operations including connecting to an FTP server, navigating directories, and downloading files.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of the FtpHook class.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.cwd","title":"<code>cwd(dir)</code>","text":"<p>Changes the current working directory on the FTP server.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>The directory to change to.</p> required"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.dir","title":"<code>dir() -&gt; list</code>","text":"<p>Lists the files and directories in the current directory of the FTP server.</p> <p>This method retrieves a list of files and directories from the FTP server's  current working directory. It populates a list with the directory entries  and returns it.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of directory entries as strings, each representing a file </p> <code>list</code> <p>or directory in the FTP server's current working directory.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.download","title":"<code>download(dir: str, filename: str) -&gt; str</code>","text":"<p>Downloads a file from the FTP server to a temporary local file.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>The directory on the FTP server where the file is located.</p> required <code>filename</code> <code>str</code> <p>The name of the file to download.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The local filepath where the downloaded file is saved.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.extract_filename","title":"<code>extract_filename(filepath_or_url: str) -&gt; str</code>","text":"<p>Extracts the filename from a filepath or URL.</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_url</code> <code>str</code> <p>The original file path or URL.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted filename.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.get_tmp_filepath","title":"<code>get_tmp_filepath(filepath_or_url: str, **kwargs) -&gt; str</code>","text":"<p>Generates a temporary file path based on the provided filepath or URL.</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_url</code> <code>str</code> <p>The original file path or URL from which the filename is extracted.</p> required Kwargs <p>add_timestamp (bool, optional):     If <code>True</code>, a timestamp and a UUID will be prefixed to the filename to ensure uniqueness.     Defaults to <code>True</code>.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The temporary file path.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.list","title":"<code>list(regex: str = None, updated_after=None, updated_before=None) -&gt; tuple</code>","text":"<p>Lists files in the current directory of the FTP server with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>A regular expression to filter file names. Defaults to None.</p> <code>None</code> <code>updated_after</code> <code>datetime</code> <p>Filter files updated after this date. Defaults to None.</p> <code>None</code> <code>updated_before</code> <code>datetime</code> <p>Filter files updated before this date. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing two lists: - A list of files (dictionaries with 'name' and 'updated_at'). - A list of directories (dictionaries with 'name' and 'updated_at').</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.list_files","title":"<code>list_files(folder: str) -&gt; list</code>","text":"<p>Lists all files in a specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder path to search for files.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of file paths found in the directory.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.login","title":"<code>login(host, user, password)</code>","text":"<p>Logs into the FTP server using the provided credentials.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The FTP server hostname or IP address.</p> required <code>user</code> <code>str</code> <p>The username for the FTP server.</p> required <code>password</code> <code>str</code> <p>The password for the FTP server.</p> required"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.rename","title":"<code>rename(from_filename: str, to_filename: str) -&gt; str</code>","text":"<p>Renames a file from the original filename to the new filename.</p> <p>Parameters:</p> Name Type Description Default <code>from_filename</code> <code>str</code> <p>The original filename to rename.</p> required <code>to_filename</code> <code>str</code> <p>The new filename.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The new filename after renaming.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.rename_files","title":"<code>rename_files(dir, prefix)</code>","text":"<p>Renames all files in a directory by prepending a prefix.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str</code> <p>The directory containing files to rename.</p> required <code>prefix</code> <code>str</code> <p>The prefix to prepend to each file name.</p> required"},{"location":"api/airless-core/hook/#airless.core.hook.FtpHook.write","title":"<code>write(local_filepath: str, data: Any, **kwargs) -&gt; None</code>","text":"<p>Writes data to a local file with support for JSON and NDJSON formats.</p> <p>Parameters:</p> Name Type Description Default <code>local_filepath</code> <code>str</code> <p>The path to the local file where the data will be written.</p> required <code>data</code> <code>Any</code> <p>The data to write to the file. It can be a string, dictionary, list, or any other type that can be serialized to JSON or converted to a string.</p> required <p>Kwargs:     use_ndjson (bool):         If <code>True</code> and the data is a dictionary or list, the data will be         written in NDJSON format. Defaults to <code>False</code>.     mode (str):         The mode in which the file is opened. Common modes include:         - <code>'w'</code>: Write mode, which overwrites the file if it exists.         - <code>'wb'</code>: Write binary mode, which overwrites the file if it exists.         Defaults to <code>'w'</code>.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.LLMHook","title":"<code>LLMHook</code>","text":"<p>               Bases: <code>BaseHook</code></p>"},{"location":"api/airless-core/hook/#airless.core.hook.QueueHook","title":"<code>QueueHook</code>","text":"<p>               Bases: <code>BaseHook</code></p> <p>Hook for interacting with a queue system.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.QueueHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the QueueHook.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.QueueHook.publish","title":"<code>publish(project: str, topic: str, data: dict) -&gt; None</code>","text":"<p>Publishes data to a specified topic.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The project name.</p> required <code>topic</code> <code>str</code> <p>The topic to publish to.</p> required <code>data</code> <code>dict</code> <p>The data to publish.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method needs to be implemented in a subclass.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.SecretManagerHook","title":"<code>SecretManagerHook</code>","text":"<p>               Bases: <code>BaseHook</code></p> <p>Hook for interacting with a secret management system.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.SecretManagerHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the SecretManagerHook.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.SecretManagerHook.add_secret_version","title":"<code>add_secret_version(project: str, id: str, value: str) -&gt; None</code>","text":"<p>Adds a new version of a secret.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The project name.</p> required <code>id</code> <code>str</code> <p>The ID of the secret.</p> required <code>value</code> <code>str</code> <p>The value of the secret.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method needs to be implemented in a subclass.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.SecretManagerHook.destroy_secret_version","title":"<code>destroy_secret_version(secret_name: str, version: str) -&gt; None</code>","text":"<p>Destroys a specific version of a secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret_name</code> <code>str</code> <p>The name of the secret.</p> required <code>version</code> <code>str</code> <p>The version of the secret to destroy.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method needs to be implemented in a subclass.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.SecretManagerHook.get_secret","title":"<code>get_secret(project: str, id: str, parse_json: bool = False) -&gt; None</code>","text":"<p>Retrieves a secret.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The project name.</p> required <code>id</code> <code>str</code> <p>The ID of the secret.</p> required <code>parse_json</code> <code>bool</code> <p>Whether to parse the secret as JSON. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method needs to be implemented in a subclass.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.SecretManagerHook.list_secret_versions","title":"<code>list_secret_versions(secret_name: str, filter: str) -&gt; None</code>","text":"<p>Lists all versions of a specific secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret_name</code> <code>str</code> <p>The name of the secret.</p> required <code>filter</code> <code>str</code> <p>The filter to apply.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method needs to be implemented in a subclass.</p>"},{"location":"api/airless-core/hook/#airless.core.hook.SecretManagerHook.list_secrets","title":"<code>list_secrets() -&gt; None</code>","text":"<p>Lists all secrets.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method needs to be implemented in a subclass.</p>"},{"location":"api/airless-core/operator/","title":"operator","text":""},{"location":"api/airless-core/operator/#airless.core.operator","title":"<code>operator</code>","text":""},{"location":"api/airless-core/operator/#airless.core.operator.__all__","title":"<code>__all__ = ['BaseHttpOperator', 'BaseFileOperator', 'BaseEventOperator', 'DelayOperator', 'ErrorReprocessOperator', 'RedirectOperator']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator","title":"<code>BaseEventOperator</code>","text":"<p>               Bases: <code>BaseOperator</code></p> <p>BaseEventOperator class to handle event trigger operations.</p> <p>This class extends BaseOperator for operations triggered by events.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the BaseEventOperator class.</p> <p>Sets the trigger type to 'event' and initializes necessary attributes.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator.execute","title":"<code>execute(data: dict, topic: str)</code>","text":"<p>Executes event processing logic.</p> <p>This method needs to be implemented in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data associated with the event.</p> required <code>topic</code> <code>str</code> <p>The event topic.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method should be implemented by subclasses.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.BaseEventOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.BaseFileOperator","title":"<code>BaseFileOperator</code>","text":"<p>               Bases: <code>BaseOperator</code></p> <p>BaseFileOperator class to handle file trigger operations.</p> <p>This class extends BaseOperator for operations triggered by files.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseFileOperator.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the BaseFileOperator class.</p> <p>Sets the trigger type to 'file' and initializes necessary attributes.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseFileOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to file operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseFileOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseFileOperator.execute","title":"<code>execute(bucket: str, filepath: str)</code>","text":"<p>Executes file processing logic.</p> <p>This method needs to be implemented in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket where the file is located.</p> required <code>filepath</code> <code>str</code> <p>The path to the file within the bucket.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method should be implemented by subclasses.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseFileOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseFileOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseFileOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes file logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the file.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.BaseHttpOperator","title":"<code>BaseHttpOperator</code>","text":"<p>               Bases: <code>BaseOperator</code></p> <p>BaseHttpOperator class to handle HTTP trigger operations.</p> <p>This class extends BaseOperator for operations triggered by HTTP requests.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseHttpOperator.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the BaseHttpOperator class.</p> <p>Sets the trigger type to 'http' and initializes necessary attributes.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseHttpOperator.build_error_message","title":"<code>build_error_message(message: str, request) -&gt; dict</code>","text":"<p>Builds an error message specific to HTTP operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>request</code> <code>Request</code> <p>The HTTP request object.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseHttpOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseHttpOperator.execute","title":"<code>execute(request)</code>","text":"<p>Executes HTTP request processing logic.</p> <p>This method needs to be implemented in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request object.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method should be implemented by subclasses.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseHttpOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseHttpOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-core/operator/#airless.core.operator.BaseHttpOperator.run","title":"<code>run(request) -&gt; None</code>","text":"<p>Processes the incoming HTTP request and executes processing logic.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request object.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator","title":"<code>DelayOperator</code>","text":"<p>               Bases: <code>BaseEventOperator</code></p> <p>Introduces a delay in the processing pipeline.</p> <p>This operator sleeps for a specified amount of time in seconds. The maximum delay is capped at 500 seconds.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the DelayOperator.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator.execute","title":"<code>execute(data: dict, topic: str) -&gt; None</code>","text":"<p>Executes the delay operation.</p> <p>The function sleeps for the number of seconds specified, capping the maximum wait time at 500 seconds.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing a key 'seconds' which determines how many seconds the operator should wait.</p> required <code>topic</code> <code>str</code> <p>The topic to which the event is associated. This parameter is not utilized in this operator.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.DelayOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator","title":"<code>ErrorReprocessOperator</code>","text":"<p>               Bases: <code>BaseEventOperator</code></p> <p>Operator to handle processing of erroneous events.</p> <p>This operator manages the retry logic for events that fail. It can reprocess events based on configured retries and intervals, and if the maximum retries are exceeded, it saves the error details to the datalake</p>"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ErrorReprocessOperator.</p> <p>Inherits from the BaseEventOperator and performs any necessary  initialization.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator.execute","title":"<code>execute(data, topic)</code>","text":"<p>Executes the error processing logic for the given data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The event data that needs to be processed.</p> required <code>topic</code> <code>str</code> <p>The topic from which the event is received.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If required keys are missing in the data dictionary.</p> <p>This method retrieves necessary metadata from the input data,  handles retries based on the specified parameters, and publishes  either the retried event back to the original topic or saves the error details to the datalake if maximum retries have been exceeded.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.ErrorReprocessOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator","title":"<code>RedirectOperator</code>","text":"<p>               Bases: <code>BaseEventOperator</code></p> <p>Operator that receives one event from a queue topic and publishes multiple  messages to another topic.</p> <p>This operator takes a dictionary of event data and publishes messages to a specified topic.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the RedirectOperator.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.add_key","title":"<code>add_key(obj: dict, keys: list, value: Any) -&gt; dict</code>","text":"<p>Adds a value to a nested dictionary at a specified key path.</p> <p>This method takes an object (dictionary), a list of keys representing  a path to a location in that dictionary, and a value to insert at  that location. If the specified nested keys do not exist in the  dictionary, they will be created.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict</code> <p>The dictionary to which the keys and value will be added.</p> required <code>keys</code> <code>list</code> <p>A list of keys representing the path in the dictionary.</p> required <code>value</code> <code>Any</code> <p>The value to be set at the specified key path.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A new dictionary with the value added at the specified key path.</p> Example <p>obj = {'a': {'b': 1}} keys = ['a', 'c'] value = 2 result = add_key(self, obj, keys, value)</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.add_key--result-will-be-a-b-1-c-2","title":"result will be {'a': {'b': 1, 'c': 2}}","text":""},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.add_param_to_message","title":"<code>add_param_to_message(message: dict, param: dict) -&gt; list</code>","text":"<p>Adds a parameter's values to a single message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>dict</code> <p>The original message to which parameters will be added.</p> required <code>param</code> <code>dict</code> <p>A dictionary containing a 'key' and a list of 'values'.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of new messages with the parameter added.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.add_param_to_messages","title":"<code>add_param_to_messages(messages: list, param: dict) -&gt; list</code>","text":"<p>Adds a single parameter to each message in a list of messages.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to modify.</p> required <code>param</code> <code>dict</code> <p>A dictionary containing a 'key' and 'values'.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of modified messages with the parameter added.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.add_params_to_messages","title":"<code>add_params_to_messages(messages: list, params: list) -&gt; list</code>","text":"<p>Adds parameters to each message in a list of messages.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to be modified.</p> required <code>params</code> <code>list of dict</code> <p>A list of parameter dictionaries, each containing a key and a list of values.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of messages with the parameters added.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.execute","title":"<code>execute(data: dict, topic: str) -&gt; None</code>","text":"<p>Executes the operator, publishing messages to a specified topic.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing event data with keys: - project (str): The project where the destination queue is hosted. - topic (str): The queue topic to which the newly generated messages will be published. - messages (list): A list of initial messages to publish. - params (list of dict): A list of parameters to modify the messages.</p> required <code>topic</code> <code>str</code> <p>The topic to publish the messages to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-core/operator/#airless.core.operator.RedirectOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-core/service/","title":"service","text":""},{"location":"api/airless-core/service/#airless.core.service","title":"<code>service</code>","text":""},{"location":"api/airless-core/service/#airless.core.service.__all__","title":"<code>__all__ = ['BaseService', 'CaptchaService']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-core/service/#airless.core.service.BaseService","title":"<code>BaseService</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Base class for services in the system.</p>"},{"location":"api/airless-core/service/#airless.core.service.BaseService.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the BaseService.</p>"},{"location":"api/airless-core/service/#airless.core.service.CaptchaService","title":"<code>CaptchaService</code>","text":"<p>               Bases: <code>BaseService</code></p> <p>Service for solving captchas.</p>"},{"location":"api/airless-core/service/#airless.core.service.CaptchaService.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the CaptchaService.</p>"},{"location":"api/airless-core/service/#airless.core.service.CaptchaService.solve","title":"<code>solve(version: str, key: str, url: str, action: str = 'verify') -&gt; str</code>","text":"<p>Solves a captcha.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>The version of the captcha (e.g., 'v2' or 'v3').</p> required <code>key</code> <code>str</code> <p>The captcha key.</p> required <code>url</code> <code>str</code> <p>The URL where the captcha is located.</p> required <code>action</code> <code>str</code> <p>The action to perform. Defaults to 'verify'.</p> <code>'verify'</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the captcha version is not implemented.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The solution to the captcha.</p>"},{"location":"api/airless-core/utils/","title":"utils","text":""},{"location":"api/airless-core/utils/#airless.core.utils","title":"<code>utils</code>","text":""},{"location":"api/airless-core/utils/#airless.core.utils.__all__","title":"<code>__all__ = ['get_config', 'BaseEnum']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-core/utils/#airless.core.utils.BaseEnum","title":"<code>BaseEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Base class for enumerations.</p>"},{"location":"api/airless-core/utils/#airless.core.utils.BaseEnum.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"<p>Checks equality with another object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>BaseEnum | dict | str</code> <p>The object to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if equal, False otherwise.</p>"},{"location":"api/airless-core/utils/#airless.core.utils.BaseEnum.find_by_id","title":"<code>find_by_id(id: str) -&gt; BaseEnum</code>  <code>classmethod</code>","text":"<p>Finds an enumeration by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID to search for.</p> required <p>Returns:</p> Name Type Description <code>BaseEnum</code> <code>BaseEnum</code> <p>The found enumeration or None if not found.</p>"},{"location":"api/airless-core/utils/#airless.core.utils.BaseEnum.list","title":"<code>list() -&gt; list</code>  <code>classmethod</code>","text":"<p>Lists all enumeration values.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of enumeration values.</p>"},{"location":"api/airless-core/utils/#airless.core.utils.get_config","title":"<code>get_config(key: str, raise_exception: bool = True, default_value: str = None) -&gt; str</code>","text":"<p>Retrieves the configuration value for a given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The configuration key to retrieve.</p> required <code>raise_exception</code> <code>bool</code> <p>Whether to raise an exception if the key is not found. Defaults to True.</p> <code>True</code> <code>default_value</code> <code>str</code> <p>The default value to return if the key is not found. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the key is not found and raise_exception is True.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The configuration value.</p>"},{"location":"api/airless-email/hook/","title":"hook","text":""},{"location":"api/airless-email/hook/#airless.email.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-email/hook/#airless.email.hook.__all__","title":"<code>__all__ = ['GoogleEmailHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-email/hook/#airless.email.hook.GoogleEmailHook","title":"<code>GoogleEmailHook</code>","text":"<p>               Bases: <code>EmailHook</code></p> <p>Hook for sending emails using Google Email service.</p>"},{"location":"api/airless-email/hook/#airless.email.hook.GoogleEmailHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GoogleEmailHook.</p>"},{"location":"api/airless-email/hook/#airless.email.hook.GoogleEmailHook.build_message","title":"<code>build_message(subject: str, content: str, recipients: list, sender: str, attachments: list = [], mime_type: str = 'plain') -&gt; Union[MIMEMultipart, MIMEText]</code>","text":"<p>Builds an email message with optional attachments.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject of the email.</p> required <code>content</code> <code>str</code> <p>The body content of the email.</p> required <code>recipients</code> <code>list</code> <p>A list of recipient email addresses.</p> required <code>sender</code> <code>str</code> <p>The email address of the sender.</p> required <code>attachments</code> <code>list</code> <p>A list of attachment dictionaries.  Each dictionary should contain 'name', 'content', and optionally 'type'.  Defaults to an empty list.</p> <code>[]</code> <code>mime_type</code> <code>str</code> <p>The MIME type of the email body content.  Defaults to 'plain'.</p> <code>'plain'</code> <p>Returns:</p> Type Description <code>Union[MIMEMultipart, MIMEText]</code> <p>Union[MIMEMultipart, MIMEText]: The constructed email message object.</p>"},{"location":"api/airless-email/hook/#airless.email.hook.GoogleEmailHook.send","title":"<code>send(subject: str, content: str, recipients: List[str], sender: str, attachments: List[dict], mime_type: str) -&gt; None</code>","text":"<p>Sends an email.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject of the email.</p> required <code>content</code> <code>str</code> <p>The content of the email.</p> required <code>recipients</code> <code>List[str]</code> <p>The list of email recipients.</p> required <code>sender</code> <code>str</code> <p>The sender's email address.</p> required <code>attachments</code> <code>List[dict]</code> <p>The list of attachments.</p> required <code>mime_type</code> <code>str</code> <p>The MIME type of the email content.</p> required"},{"location":"api/airless-email/operator/","title":"operator","text":""},{"location":"api/airless-email/operator/#airless.email.operator","title":"<code>operator</code>","text":""},{"location":"api/airless-email/operator/#airless.email.operator.__all__","title":"<code>__all__ = ['GoogleEmailSendOperator']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator","title":"<code>GoogleEmailSendOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code></p> <p>Operator for sending emails using Google Email Hook.</p>"},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GoogleEmailSendOperator.</p>"},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator.execute","title":"<code>execute(data: dict, topic: str) -&gt; None</code>","text":"<p>Executes the email sending process.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data containing email information.</p> required <code>topic</code> <code>str</code> <p>The Pub/Sub topic.</p> required"},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-email/operator/#airless.email.operator.GoogleEmailSendOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-bigquery/hook/","title":"hook","text":""},{"location":"api/airless-google-cloud-bigquery/hook/#airless.google.cloud.bigquery.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-google-cloud-bigquery/hook/#airless.google.cloud.bigquery.hook.__all__","title":"<code>__all__ = ['BigqueryHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-google-cloud-bigquery/hook/#airless.google.cloud.bigquery.hook.BigqueryHook","title":"<code>BigqueryHook</code>","text":"<p>               Bases: <code>BaseHook</code></p>"},{"location":"api/airless-google-cloud-bigquery/operator/","title":"operator","text":""},{"location":"api/airless-google-cloud-bigquery/operator/#airless.slack.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-google-cloud-bigquery/operator/#airless.slack.hook.__all__","title":"<code>__all__ = ['SlackHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-google-cloud-bigquery/operator/#airless.slack.hook.SlackHook","title":"<code>SlackHook</code>","text":"<p>               Bases: <code>BaseHook</code></p> <p>Hook for interacting with Slack API.</p>"},{"location":"api/airless-google-cloud-bigquery/operator/#airless.slack.hook.SlackHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the SlackHook.</p>"},{"location":"api/airless-google-cloud-bigquery/operator/#airless.slack.hook.SlackHook.get_headers","title":"<code>get_headers() -&gt; Dict[str, str]</code>","text":"<p>Gets the headers for the Slack API requests.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: The headers including the authorization token.</p>"},{"location":"api/airless-google-cloud-bigquery/operator/#airless.slack.hook.SlackHook.react","title":"<code>react(channel: str, reaction: str, ts: str) -&gt; Dict[str, Any]</code>","text":"<p>Adds a reaction to a Slack message.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>str</code> <p>The channel of the message.</p> required <code>reaction</code> <code>str</code> <p>The reaction to add.</p> required <code>ts</code> <code>str</code> <p>The timestamp of the message.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The response from the Slack API.</p>"},{"location":"api/airless-google-cloud-bigquery/operator/#airless.slack.hook.SlackHook.send","title":"<code>send(channel: Optional[str] = None, message: Optional[str] = None, blocks: Optional[List[Dict[str, Any]]] = None, thread_ts: Optional[str] = None, reply_broadcast: bool = False, attachments: Optional[List[Dict[str, Any]]] = None, response_url: Optional[str] = None, response_type: Optional[str] = None, replace_original: Optional[bool] = None) -&gt; Dict[str, Any]</code>","text":"<p>Sends a message to a Slack channel or a response URL.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Optional[str]</code> <p>The channel to send the message to.</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>The message text.</p> <code>None</code> <code>blocks</code> <code>Optional[List[Dict[str, Any]]]</code> <p>The message blocks.</p> <code>None</code> <code>thread_ts</code> <code>Optional[str]</code> <p>The timestamp of the thread to reply to.</p> <code>None</code> <code>reply_broadcast</code> <code>bool</code> <p>Whether to broadcast the reply to the channel.</p> <code>False</code> <code>attachments</code> <code>Optional[List[Dict[str, Any]]]</code> <p>The message attachments.</p> <code>None</code> <code>response_url</code> <code>Optional[str]</code> <p>The response URL to send the message to.</p> <code>None</code> <code>response_type</code> <code>Optional[str]</code> <p>The response type.</p> <code>None</code> <code>replace_original</code> <code>Optional[bool]</code> <p>Whether to replace the original message.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The response from the Slack API.</p>"},{"location":"api/airless-google-cloud-bigquery/operator/#airless.slack.hook.SlackHook.set_token","title":"<code>set_token(token: str) -&gt; None</code>","text":"<p>Sets the authorization token for the Slack API.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The authorization token.</p> required"},{"location":"api/airless-google-cloud-core/core/operator/","title":"operator","text":""},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator","title":"<code>operator</code>","text":""},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.__all__","title":"<code>__all__ = ['GoogleBaseEventOperator', 'GoogleBaseFileOperator', 'GoogleDelayOperator', 'GoogleRedirectOperator']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator","title":"<code>GoogleBaseEventOperator</code>","text":"<p>               Bases: <code>BaseEventOperator</code></p> <p>Base operator for event operations in Google Cloud.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GoogleBaseEventOperator.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator.execute","title":"<code>execute(data: dict, topic: str)</code>","text":"<p>Executes event processing logic.</p> <p>This method needs to be implemented in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data associated with the event.</p> required <code>topic</code> <code>str</code> <p>The event topic.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method should be implemented by subclasses.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseEventOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseFileOperator","title":"<code>GoogleBaseFileOperator</code>","text":"<p>               Bases: <code>BaseFileOperator</code></p> <p>Base operator for file operations in Google Cloud.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseFileOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GoogleBaseFileOperator.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseFileOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to file operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseFileOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseFileOperator.execute","title":"<code>execute(bucket: str, filepath: str)</code>","text":"<p>Executes file processing logic.</p> <p>This method needs to be implemented in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket where the file is located.</p> required <code>filepath</code> <code>str</code> <p>The path to the file within the bucket.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method should be implemented by subclasses.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseFileOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseFileOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleBaseFileOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes file logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the file.</p> required"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleDelayOperator","title":"<code>GoogleDelayOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code>, <code>DelayOperator</code></p> <p>Operator that adds a delay to the pipeline.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleDelayOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleDelayOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleDelayOperator.execute","title":"<code>execute(data: dict, topic: str) -&gt; None</code>","text":"<p>Executes the delay operation.</p> <p>The function sleeps for the number of seconds specified, capping the maximum wait time at 500 seconds.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing a key 'seconds' which determines how many seconds the operator should wait.</p> required <code>topic</code> <code>str</code> <p>The topic to which the event is associated. This parameter is not utilized in this operator.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleDelayOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleDelayOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleDelayOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleDelayOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator","title":"<code>GoogleRedirectOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code>, <code>RedirectOperator</code></p> <p>Google Cloud implementation of RedirectOperator.</p> <p>Operator that receives one event from a Google Pub/Sub topic and publishes  multiple messages to another topic.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.add_key","title":"<code>add_key(obj: dict, keys: list, value: Any) -&gt; dict</code>","text":"<p>Adds a value to a nested dictionary at a specified key path.</p> <p>This method takes an object (dictionary), a list of keys representing  a path to a location in that dictionary, and a value to insert at  that location. If the specified nested keys do not exist in the  dictionary, they will be created.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict</code> <p>The dictionary to which the keys and value will be added.</p> required <code>keys</code> <code>list</code> <p>A list of keys representing the path in the dictionary.</p> required <code>value</code> <code>Any</code> <p>The value to be set at the specified key path.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A new dictionary with the value added at the specified key path.</p> Example <p>obj = {'a': {'b': 1}} keys = ['a', 'c'] value = 2 result = add_key(self, obj, keys, value)</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.add_key--result-will-be-a-b-1-c-2","title":"result will be {'a': {'b': 1, 'c': 2}}","text":""},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.add_param_to_message","title":"<code>add_param_to_message(message: dict, param: dict) -&gt; list</code>","text":"<p>Adds a parameter's values to a single message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>dict</code> <p>The original message to which parameters will be added.</p> required <code>param</code> <code>dict</code> <p>A dictionary containing a 'key' and a list of 'values'.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of new messages with the parameter added.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.add_param_to_messages","title":"<code>add_param_to_messages(messages: list, param: dict) -&gt; list</code>","text":"<p>Adds a single parameter to each message in a list of messages.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to modify.</p> required <code>param</code> <code>dict</code> <p>A dictionary containing a 'key' and 'values'.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of modified messages with the parameter added.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.add_params_to_messages","title":"<code>add_params_to_messages(messages: list, params: list) -&gt; list</code>","text":"<p>Adds parameters to each message in a list of messages.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to be modified.</p> required <code>params</code> <code>list of dict</code> <p>A list of parameter dictionaries, each containing a key and a list of values.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of messages with the parameters added.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.execute","title":"<code>execute(data: dict, topic: str) -&gt; None</code>","text":"<p>Executes the operator, publishing messages to a specified topic.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing event data with keys: - project (str): The project where the destination queue is hosted. - topic (str): The queue topic to which the newly generated messages will be published. - messages (list): A list of initial messages to publish. - params (list of dict): A list of parameters to modify the messages.</p> required <code>topic</code> <code>str</code> <p>The topic to publish the messages to.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-core/core/operator/#airless.google.cloud.core.operator.GoogleRedirectOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-core/pubsub/hook/","title":"hook","text":""},{"location":"api/airless-google-cloud-core/pubsub/hook/#airless.google.cloud.pubsub.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-google-cloud-core/pubsub/hook/#airless.google.cloud.pubsub.hook.__all__","title":"<code>__all__ = ['GooglePubsubHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-google-cloud-core/pubsub/hook/#airless.google.cloud.pubsub.hook.GooglePubsubHook","title":"<code>GooglePubsubHook</code>","text":"<p>               Bases: <code>QueueHook</code></p> <p>Hook for interacting with Google Pub/Sub.</p>"},{"location":"api/airless-google-cloud-core/pubsub/hook/#airless.google.cloud.pubsub.hook.GooglePubsubHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GooglePubsubHook.</p>"},{"location":"api/airless-google-cloud-core/pubsub/hook/#airless.google.cloud.pubsub.hook.GooglePubsubHook.publish","title":"<code>publish(project: str, topic: str, data: Any) -&gt; str</code>","text":"<p>Publishes a message to a specified Pub/Sub topic.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The GCP project ID.</p> required <code>topic</code> <code>str</code> <p>The Pub/Sub topic name.</p> required <code>data</code> <code>Any</code> <p>The data to publish.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A confirmation message.</p>"},{"location":"api/airless-google-cloud-secret-manager/hook/","title":"hook","text":""},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook.__all__","title":"<code>__all__ = ['GoogleSecretManagerHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook.GoogleSecretManagerHook","title":"<code>GoogleSecretManagerHook</code>","text":"<p>               Bases: <code>SecretManagerHook</code></p> <p>Hook for interacting with Google Secret Manager.</p>"},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook.GoogleSecretManagerHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GoogleSecretManagerHook.</p>"},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook.GoogleSecretManagerHook.add_secret_version","title":"<code>add_secret_version(project: str, id: str, value: Any) -&gt; Any</code>","text":"<p>Adds a new version to a secret.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The project ID.</p> required <code>id</code> <code>str</code> <p>The secret ID.</p> required <code>value</code> <code>Any</code> <p>The value to store in the secret.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response from the secret manager.</p>"},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook.GoogleSecretManagerHook.destroy_secret_version","title":"<code>destroy_secret_version(secret_name: str, version: str) -&gt; str</code>","text":"<p>Destroys a specific version of a secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret_name</code> <code>str</code> <p>The name of the secret.</p> required <code>version</code> <code>str</code> <p>The version of the secret to destroy.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the destroyed version.</p>"},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook.GoogleSecretManagerHook.get_secret","title":"<code>get_secret(project: str, id: str, parse_json: bool = False) -&gt; Any</code>","text":"<p>Retrieves the latest version of a secret.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The project ID.</p> required <code>id</code> <code>str</code> <p>The secret ID.</p> required <code>parse_json</code> <code>bool</code> <p>Whether to parse the secret as JSON. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The secret value, parsed if requested.</p>"},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook.GoogleSecretManagerHook.list_secret_versions","title":"<code>list_secret_versions(secret_name: str, filter: str = 'state:(ENABLED OR DISABLED)') -&gt; List[str]</code>","text":"<p>Lists all versions of a specified secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret_name</code> <code>str</code> <p>The name of the secret.</p> required <code>filter</code> <code>str</code> <p>The filter for the versions. Defaults to 'state:(ENABLED OR DISABLED)'.</p> <code>'state:(ENABLED OR DISABLED)'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of secret version names.</p>"},{"location":"api/airless-google-cloud-secret-manager/hook/#airless.google.cloud.secret_manager.hook.GoogleSecretManagerHook.list_secrets","title":"<code>list_secrets() -&gt; List[str]</code>","text":"<p>Lists all secrets in the project.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of secret names.</p>"},{"location":"api/airless-google-cloud-storage/hook/","title":"hook","text":""},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.__all__","title":"<code>__all__ = ['GcsHook', 'GcsDatalakeHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook","title":"<code>GcsDatalakeHook</code>","text":"<p>               Bases: <code>GcsHook</code>, <code>DatalakeHook</code></p> <p>Hook for interacting with GCS Datalake.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GcsDatalakeHook.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.build_filepath","title":"<code>build_filepath(bucket: str, filepath: str) -&gt; str</code>","text":"<p>Builds the full GCS file path.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full GCS file path.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.build_metadata","title":"<code>build_metadata(message_id: Optional[int], origin: Optional[str]) -&gt; Dict[str, Any]</code>","text":"<p>Builds metadata for the data being sent.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>Optional[int]</code> <p>The message ID.</p> required <code>origin</code> <code>Optional[str]</code> <p>The origin of the data.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The metadata dictionary.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.check_existance","title":"<code>check_existance(bucket: str, filepath: str) -&gt; bool</code>","text":"<p>Checks if a file exists in GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the file exists, False otherwise.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.copy_blobs","title":"<code>copy_blobs(bucket: storage.Bucket, blobs: List[storage.Blob], to_bucket: storage.Bucket, to_directory: str) -&gt; None</code>","text":"<p>Copies blobs from one bucket to another.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>Bucket</code> <p>The source bucket.</p> required <code>blobs</code> <code>List[Blob]</code> <p>The list of blobs to copy.</p> required <code>to_bucket</code> <code>Bucket</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.delete","title":"<code>delete(bucket_name: str, prefix: Optional[str] = None, files: Optional[List[str]] = None) -&gt; None</code>","text":"<p>Deletes files from GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>prefix</code> <code>Optional[str]</code> <p>The prefix for files to delete. Defaults to None.</p> <code>None</code> <code>files</code> <code>Optional[List[str]]</code> <p>The list of specific files to delete. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.delete_blobs","title":"<code>delete_blobs(blobs: List[storage.Blob]) -&gt; None</code>","text":"<p>Deletes a list of blobs.</p> <p>Parameters:</p> Name Type Description Default <code>blobs</code> <code>List[Blob]</code> <p>The list of blobs to delete.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.download","title":"<code>download(bucket: str, filepath: str, target_filepath: Optional[str] = None) -&gt; None</code>","text":"<p>Downloads a file from GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>target_filepath</code> <code>Optional[str]</code> <p>The target file path. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.files_to_blobs","title":"<code>files_to_blobs(bucket: storage.Bucket, files: List[str]) -&gt; List[storage.Blob]</code>","text":"<p>Converts a list of file names to blobs.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>Bucket</code> <p>The GCS bucket.</p> required <code>files</code> <code>List[str]</code> <p>The list of file names.</p> required <p>Returns:</p> Type Description <code>List[Blob]</code> <p>List[storage.Blob]: The list of blobs.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.list","title":"<code>list(bucket_name: str, prefix: Optional[str] = None) -&gt; List[storage.Blob]</code>","text":"<p>Lists blobs in a GCS bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>prefix</code> <code>Optional[str]</code> <p>The prefix to filter blobs. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Blob]</code> <p>List[storage.Blob]: The list of blobs.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.move","title":"<code>move(from_bucket: str, from_prefix: str, to_bucket: str, to_directory: str, rewrite: bool) -&gt; None</code>","text":"<p>Moves files from one GCS location to another.</p> <p>Parameters:</p> Name Type Description Default <code>from_bucket</code> <code>str</code> <p>The source bucket.</p> required <code>from_prefix</code> <code>str</code> <p>The source prefix.</p> required <code>to_bucket</code> <code>str</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required <code>rewrite</code> <code>bool</code> <p>Whether to overwrite existing files.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.move_blobs","title":"<code>move_blobs(bucket: storage.Bucket, blobs: List[storage.Blob], to_bucket: storage.Bucket, to_directory: str, rewrite: bool) -&gt; None</code>","text":"<p>Moves blobs from one bucket to another.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>Bucket</code> <p>The source bucket.</p> required <code>blobs</code> <code>List[Blob]</code> <p>The list of blobs to move.</p> required <code>to_bucket</code> <code>Bucket</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required <code>rewrite</code> <code>bool</code> <p>Whether to overwrite existing files.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.move_files","title":"<code>move_files(from_bucket: str, files: List[str], to_bucket: str, to_directory: str, rewrite: bool) -&gt; None</code>","text":"<p>Moves specified files from one GCS location to another.</p> <p>Parameters:</p> Name Type Description Default <code>from_bucket</code> <code>str</code> <p>The source bucket.</p> required <code>files</code> <code>List[str]</code> <p>The list of files to move.</p> required <code>to_bucket</code> <code>str</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required <code>rewrite</code> <code>bool</code> <p>Whether to overwrite existing files.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.prepare_row","title":"<code>prepare_row(row: Any, metadata: Dict[str, Any], now: datetime) -&gt; Dict[str, Any]</code>","text":"<p>Prepares a row for insertion into the datalake.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Any</code> <p>The row data.</p> required <code>metadata</code> <code>Dict[str, Any]</code> <p>The metadata for the row.</p> required <code>now</code> <code>datetime</code> <p>The current timestamp.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The prepared row.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.prepare_rows","title":"<code>prepare_rows(data: Any, metadata: Dict[str, Any]) -&gt; Tuple[List[Dict[str, Any]], datetime]</code>","text":"<p>Prepares multiple rows for insertion into the datalake.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to prepare.</p> required <code>metadata</code> <code>Dict[str, Any]</code> <p>The metadata for the rows.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Dict[str, Any]], datetime]</code> <p>Tuple[List[Dict[str, Any]], datetime]: The prepared rows and the current timestamp.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.read_as_bytes","title":"<code>read_as_bytes(bucket: str, filepath: str) -&gt; bytes</code>","text":"<p>Reads a file from GCS as bytes.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The content of the file as bytes.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.read_as_string","title":"<code>read_as_string(bucket: str, filepath: str, encoding: Optional[str] = None) -&gt; str</code>","text":"<p>Reads a file from GCS as a string.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>encoding</code> <code>Optional[str]</code> <p>The encoding to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The content of the file as a string.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.read_json","title":"<code>read_json(bucket: str, filepath: str, encoding: Optional[str] = None) -&gt; Any</code>","text":"<p>Reads a JSON file from GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>encoding</code> <code>Optional[str]</code> <p>The encoding to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The content of the JSON file.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.read_ndjson","title":"<code>read_ndjson(bucket: str, filepath: str, encoding: Optional[str] = None) -&gt; List[Any]</code>","text":"<p>Reads an NDJSON file from GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>encoding</code> <code>Optional[str]</code> <p>The encoding to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]: The content of the NDJSON file.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.rewrite_blobs","title":"<code>rewrite_blobs(blobs: List[storage.Blob], to_bucket: storage.Bucket, to_directory: str) -&gt; None</code>","text":"<p>Rewrites blobs in the destination bucket.</p> <p>Parameters:</p> Name Type Description Default <code>blobs</code> <code>List[Blob]</code> <p>The list of blobs to rewrite.</p> required <code>to_bucket</code> <code>Bucket</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.send_to_landing_zone","title":"<code>send_to_landing_zone(data: Any, dataset: str, table: str, message_id: Optional[int], origin: Optional[str], time_partition: bool = False) -&gt; Union[str, None]</code>","text":"<p>Sends data to the landing zone in GCS.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to send.</p> required <code>dataset</code> <code>str</code> <p>The dataset name.</p> required <code>table</code> <code>str</code> <p>The table name.</p> required <code>message_id</code> <code>Optional[int]</code> <p>The message ID.</p> required <code>origin</code> <code>Optional[str]</code> <p>The origin of the data.</p> required <code>time_partition</code> <code>bool</code> <p>Whether to use time partitioning. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>Union[str, None]: The path to the uploaded file or None.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.upload","title":"<code>upload(local_filepath: str, bucket_name: str, directory: str) -&gt; str</code>","text":"<p>Uploads a local file to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>local_filepath</code> <code>str</code> <p>The path to the local file.</p> required <code>bucket_name</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>directory</code> <code>str</code> <p>The directory within the bucket.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the uploaded file in GCS.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.upload_folder","title":"<code>upload_folder(local_path: str, bucket: str, gcs_path: str) -&gt; None</code>","text":"<p>Uploads a folder to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>str</code> <p>The local folder path.</p> required <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>gcs_path</code> <code>str</code> <p>The GCS path to upload to.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.upload_from_memory","title":"<code>upload_from_memory(data: Any, bucket: str, directory: str, filename: str, **kwargs: Any) -&gt; str</code>","text":"<p>Uploads data from memory to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to upload.</p> required <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>directory</code> <code>str</code> <p>The directory within the bucket.</p> required <code>filename</code> <code>str</code> <p>The name of the file to create.</p> required Kwargs <p>add_timestamp (bool, optional): If True, adds a timestamp to the filename. Defaults to True. use_ndjson (bool, optional): If True, writes data in NDJSON format. Defaults to False. mode (str, optional): The mode for opening the file. Defaults to 'w'.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the uploaded file.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsDatalakeHook.upload_parquet_from_memory","title":"<code>upload_parquet_from_memory(data: Any, bucket: str, directory: str, filename: str, **kwargs: Any) -&gt; str</code>","text":"<p>Uploads Parquet data from memory to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to upload.</p> required <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>directory</code> <code>str</code> <p>The directory within the bucket.</p> required <code>filename</code> <code>str</code> <p>The name of the Parquet file to create.</p> required Kwargs <p>schema (pa.Schema, optional): The schema for the Parquet table. Defaults to None. add_timestamp (bool, optional): If True, adds a timestamp to the filename. Defaults to True.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the uploaded Parquet file.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook","title":"<code>GcsHook</code>","text":"<p>               Bases: <code>BaseHook</code></p> <p>Hook for interacting with Google Cloud Storage.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GcsHook.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.build_filepath","title":"<code>build_filepath(bucket: str, filepath: str) -&gt; str</code>","text":"<p>Builds the full GCS file path.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full GCS file path.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.check_existance","title":"<code>check_existance(bucket: str, filepath: str) -&gt; bool</code>","text":"<p>Checks if a file exists in GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the file exists, False otherwise.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.copy_blobs","title":"<code>copy_blobs(bucket: storage.Bucket, blobs: List[storage.Blob], to_bucket: storage.Bucket, to_directory: str) -&gt; None</code>","text":"<p>Copies blobs from one bucket to another.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>Bucket</code> <p>The source bucket.</p> required <code>blobs</code> <code>List[Blob]</code> <p>The list of blobs to copy.</p> required <code>to_bucket</code> <code>Bucket</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.delete","title":"<code>delete(bucket_name: str, prefix: Optional[str] = None, files: Optional[List[str]] = None) -&gt; None</code>","text":"<p>Deletes files from GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>prefix</code> <code>Optional[str]</code> <p>The prefix for files to delete. Defaults to None.</p> <code>None</code> <code>files</code> <code>Optional[List[str]]</code> <p>The list of specific files to delete. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.delete_blobs","title":"<code>delete_blobs(blobs: List[storage.Blob]) -&gt; None</code>","text":"<p>Deletes a list of blobs.</p> <p>Parameters:</p> Name Type Description Default <code>blobs</code> <code>List[Blob]</code> <p>The list of blobs to delete.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.download","title":"<code>download(bucket: str, filepath: str, target_filepath: Optional[str] = None) -&gt; None</code>","text":"<p>Downloads a file from GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>target_filepath</code> <code>Optional[str]</code> <p>The target file path. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.files_to_blobs","title":"<code>files_to_blobs(bucket: storage.Bucket, files: List[str]) -&gt; List[storage.Blob]</code>","text":"<p>Converts a list of file names to blobs.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>Bucket</code> <p>The GCS bucket.</p> required <code>files</code> <code>List[str]</code> <p>The list of file names.</p> required <p>Returns:</p> Type Description <code>List[Blob]</code> <p>List[storage.Blob]: The list of blobs.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.list","title":"<code>list(bucket_name: str, prefix: Optional[str] = None) -&gt; List[storage.Blob]</code>","text":"<p>Lists blobs in a GCS bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>prefix</code> <code>Optional[str]</code> <p>The prefix to filter blobs. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Blob]</code> <p>List[storage.Blob]: The list of blobs.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.move","title":"<code>move(from_bucket: str, from_prefix: str, to_bucket: str, to_directory: str, rewrite: bool) -&gt; None</code>","text":"<p>Moves files from one GCS location to another.</p> <p>Parameters:</p> Name Type Description Default <code>from_bucket</code> <code>str</code> <p>The source bucket.</p> required <code>from_prefix</code> <code>str</code> <p>The source prefix.</p> required <code>to_bucket</code> <code>str</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required <code>rewrite</code> <code>bool</code> <p>Whether to overwrite existing files.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.move_blobs","title":"<code>move_blobs(bucket: storage.Bucket, blobs: List[storage.Blob], to_bucket: storage.Bucket, to_directory: str, rewrite: bool) -&gt; None</code>","text":"<p>Moves blobs from one bucket to another.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>Bucket</code> <p>The source bucket.</p> required <code>blobs</code> <code>List[Blob]</code> <p>The list of blobs to move.</p> required <code>to_bucket</code> <code>Bucket</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required <code>rewrite</code> <code>bool</code> <p>Whether to overwrite existing files.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.move_files","title":"<code>move_files(from_bucket: str, files: List[str], to_bucket: str, to_directory: str, rewrite: bool) -&gt; None</code>","text":"<p>Moves specified files from one GCS location to another.</p> <p>Parameters:</p> Name Type Description Default <code>from_bucket</code> <code>str</code> <p>The source bucket.</p> required <code>files</code> <code>List[str]</code> <p>The list of files to move.</p> required <code>to_bucket</code> <code>str</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required <code>rewrite</code> <code>bool</code> <p>Whether to overwrite existing files.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.read_as_bytes","title":"<code>read_as_bytes(bucket: str, filepath: str) -&gt; bytes</code>","text":"<p>Reads a file from GCS as bytes.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The content of the file as bytes.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.read_as_string","title":"<code>read_as_string(bucket: str, filepath: str, encoding: Optional[str] = None) -&gt; str</code>","text":"<p>Reads a file from GCS as a string.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>encoding</code> <code>Optional[str]</code> <p>The encoding to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The content of the file as a string.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.read_json","title":"<code>read_json(bucket: str, filepath: str, encoding: Optional[str] = None) -&gt; Any</code>","text":"<p>Reads a JSON file from GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>encoding</code> <code>Optional[str]</code> <p>The encoding to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The content of the JSON file.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.read_ndjson","title":"<code>read_ndjson(bucket: str, filepath: str, encoding: Optional[str] = None) -&gt; List[Any]</code>","text":"<p>Reads an NDJSON file from GCS.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>encoding</code> <code>Optional[str]</code> <p>The encoding to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]: The content of the NDJSON file.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.rewrite_blobs","title":"<code>rewrite_blobs(blobs: List[storage.Blob], to_bucket: storage.Bucket, to_directory: str) -&gt; None</code>","text":"<p>Rewrites blobs in the destination bucket.</p> <p>Parameters:</p> Name Type Description Default <code>blobs</code> <code>List[Blob]</code> <p>The list of blobs to rewrite.</p> required <code>to_bucket</code> <code>Bucket</code> <p>The destination bucket.</p> required <code>to_directory</code> <code>str</code> <p>The destination directory.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.upload","title":"<code>upload(local_filepath: str, bucket_name: str, directory: str) -&gt; str</code>","text":"<p>Uploads a local file to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>local_filepath</code> <code>str</code> <p>The path to the local file.</p> required <code>bucket_name</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>directory</code> <code>str</code> <p>The directory within the bucket.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the uploaded file in GCS.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.upload_folder","title":"<code>upload_folder(local_path: str, bucket: str, gcs_path: str) -&gt; None</code>","text":"<p>Uploads a folder to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>str</code> <p>The local folder path.</p> required <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>gcs_path</code> <code>str</code> <p>The GCS path to upload to.</p> required"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.upload_from_memory","title":"<code>upload_from_memory(data: Any, bucket: str, directory: str, filename: str, **kwargs: Any) -&gt; str</code>","text":"<p>Uploads data from memory to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to upload.</p> required <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>directory</code> <code>str</code> <p>The directory within the bucket.</p> required <code>filename</code> <code>str</code> <p>The name of the file to create.</p> required Kwargs <p>add_timestamp (bool, optional): If True, adds a timestamp to the filename. Defaults to True. use_ndjson (bool, optional): If True, writes data in NDJSON format. Defaults to False. mode (str, optional): The mode for opening the file. Defaults to 'w'.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the uploaded file.</p>"},{"location":"api/airless-google-cloud-storage/hook/#airless.google.cloud.storage.hook.GcsHook.upload_parquet_from_memory","title":"<code>upload_parquet_from_memory(data: Any, bucket: str, directory: str, filename: str, **kwargs: Any) -&gt; str</code>","text":"<p>Uploads Parquet data from memory to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to upload.</p> required <code>bucket</code> <code>str</code> <p>The name of the GCS bucket.</p> required <code>directory</code> <code>str</code> <p>The directory within the bucket.</p> required <code>filename</code> <code>str</code> <p>The name of the Parquet file to create.</p> required Kwargs <p>schema (pa.Schema, optional): The schema for the Parquet table. Defaults to None. add_timestamp (bool, optional): If True, adds a timestamp to the filename. Defaults to True.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the uploaded Parquet file.</p>"},{"location":"api/airless-google-cloud-storage/operator/","title":"operator","text":""},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator","title":"<code>operator</code>","text":""},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.__all__","title":"<code>__all__ = ['FileUrlToGcsOperator', 'FtpToGcsOperator', 'FileDetectOperator', 'BatchWriteDetectOperator', 'BatchWriteProcessOperator', 'FileDeleteOperator', 'FileMoveOperator', 'GoogleErrorReprocessOperator']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteDetectOperator","title":"<code>BatchWriteDetectOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code></p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteDetectOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteDetectOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteDetectOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteDetectOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteDetectOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteDetectOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteProcessOperator","title":"<code>BatchWriteProcessOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code></p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteProcessOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteProcessOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteProcessOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteProcessOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteProcessOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.BatchWriteProcessOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDeleteOperator","title":"<code>FileDeleteOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code></p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDeleteOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDeleteOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDeleteOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDeleteOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDeleteOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDeleteOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDetectOperator","title":"<code>FileDetectOperator</code>","text":"<p>               Bases: <code>GoogleBaseFileOperator</code></p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDetectOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to file operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDetectOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDetectOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDetectOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileDetectOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes file logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the file.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileMoveOperator","title":"<code>FileMoveOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code></p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileMoveOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileMoveOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileMoveOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileMoveOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileMoveOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileMoveOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator","title":"<code>FileUrlToGcsOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code></p> <p>Operator for transferring files from a URL to GCS.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the FileUrlToGcsOperator.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.execute","title":"<code>execute(data: Dict[str, Any], topic: str) -&gt; None</code>","text":"<p>Executes the file transfer from URL to GCS.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data containing URL and GCS information.</p> required <code>topic</code> <code>str</code> <p>The Pub/Sub topic.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.move_to_destinations","title":"<code>move_to_destinations(local_filepath: str, destination: Union[Dict[str, Any], List[Dict[str, Any]]]) -&gt; None</code>","text":"<p>Moves the downloaded file to the specified destinations.</p> <p>Parameters:</p> Name Type Description Default <code>local_filepath</code> <code>str</code> <p>The local file path.</p> required <code>destination</code> <code>Union[Dict[str, Any], List[Dict[str, Any]]]</code> <p>The destination(s) for the file.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.remove_null_byte","title":"<code>remove_null_byte(local_filepath: str) -&gt; None</code>","text":"<p>Removes null bytes from the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>local_filepath</code> <code>str</code> <p>The local file path.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FileUrlToGcsOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator","title":"<code>FtpToGcsOperator</code>","text":"<p>               Bases: <code>FileUrlToGcsOperator</code></p> <p>Operator for transferring files from FTP to GCS.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the FtpToGcsOperator.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.execute","title":"<code>execute(data: Dict[str, str], topic: str) -&gt; None</code>","text":"<p>Executes the FTP to GCS transfer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, str]</code> <p>The data containing FTP and GCS information.</p> required <code>topic</code> <code>str</code> <p>The Pub/Sub topic.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.move_to_destinations","title":"<code>move_to_destinations(local_filepath: str, destination: Union[Dict[str, Any], List[Dict[str, Any]]]) -&gt; None</code>","text":"<p>Moves the downloaded file to the specified destinations.</p> <p>Parameters:</p> Name Type Description Default <code>local_filepath</code> <code>str</code> <p>The local file path.</p> required <code>destination</code> <code>Union[Dict[str, Any], List[Dict[str, Any]]]</code> <p>The destination(s) for the file.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.remove_null_byte","title":"<code>remove_null_byte(local_filepath: str) -&gt; None</code>","text":"<p>Removes null bytes from the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>local_filepath</code> <code>str</code> <p>The local file path.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.FtpToGcsOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator","title":"<code>GoogleErrorReprocessOperator</code>","text":"<p>               Bases: <code>GoogleBaseEventOperator</code>, <code>ErrorReprocessOperator</code></p> <p>Operator for reprocessing errors in Google Cloud.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GoogleErrorReprocessOperator.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator.execute","title":"<code>execute(data, topic)</code>","text":"<p>Executes the error processing logic for the given data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The event data that needs to be processed.</p> required <code>topic</code> <code>str</code> <p>The topic from which the event is received.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If required keys are missing in the data dictionary.</p> <p>This method retrieves necessary metadata from the input data,  handles retries based on the specified parameters, and publishes  either the retried event back to the original topic or saves the error details to the datalake if maximum retries have been exceeded.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-google-cloud-storage/operator/#airless.google.cloud.storage.operator.GoogleErrorReprocessOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-google-cloud-vertexai/hook/","title":"hook","text":""},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.__all__","title":"<code>__all__ = ['VertexAiHook', 'GeminiApiHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.GeminiApiHook","title":"<code>GeminiApiHook</code>","text":"<p>               Bases: <code>LLMHook</code></p>"},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.GeminiApiHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Gemini api only hook</p> Note <p>Requires the following environment variables to be set:</p> <ul> <li>GEMINI_API_KEY: Gemini api key string.</li> </ul>"},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.GeminiApiHook.extract_text_from_response","title":"<code>extract_text_from_response(response_json: dict) -&gt; str</code>","text":"<p>Extracts text content from a Gemini API JSON response.</p> <p>Parameters:</p> Name Type Description Default <code>response_json</code> <code>dict</code> <p>The JSON response from the Gemini API as a dictionary.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The extracted text content if found. Raises ValueError if extraction fails or the prompt was blocked.</p>"},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.GeminiApiHook.generate_content","title":"<code>generate_content(model: str, prompt: str = None, **kwargs: dict[str, Any]) -&gt; dict</code>","text":"<p>Generates content using the Gemini API via a POST request.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The name of the Gemini model to use.</p> required <code>prompt</code> <code>str</code> <p>Text prompt for generation.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional parameters to include in the request payload, such as systemInstruction or generationConfig.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; response = gemini_hook.generate_content(\n...     model=\"gemini-2.0-flash-lite\",\n...     prompt=\"Summarize this article about climate change...\",\n...     systemInstruction={\"parts\": [{\"text\": \"You are an expert summarizer. Provide a concise summary.\"}]},\n...     generationConfig={\"responseMimeType\": \"text/plain\", \"temperature\": 0.2}\n... )\n</code></pre> <p>Example with custom contents structure</p> <pre><code>&gt;&gt;&gt; response = gemini_hook.generate_content(\n...     model=\"gemini-2.0-flash-lite\",\n...     systemInstruction={\n...         \"parts\": [{\"text\": \"You are an expert summarizer. Provide a concise summary in Portuguese.\"}]\n...     },\n...     contents=[{\n...         \"role\": \"user\",\n...         \"parts\": [\n...             {\"text\": \"First part of the article...\"},\n...             {\"text\": \"Second part with more details...\"}\n...         ]\n...     }],\n...     generationConfig={\"responseMimeType\": \"text/plain\", \"temperature\": 0.2}\n... )\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>The full JSON response from the Gemini API as a dictionary.</p>"},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.GeminiApiHook.generate_content_with_pdf","title":"<code>generate_content_with_pdf(model: str, prompt: str = None, pdf_files: list[str] = None, **kwargs: dict[str, Any]) -&gt; dict</code>","text":"<p>Generates content using the Gemini API with PDF context via a POST request.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The name of the Gemini model to use.</p> required <code>prompt</code> <code>str</code> <p>The text prompt for generation.</p> <code>None</code> <code>pdf_files</code> <code>list[str]</code> <p>A list of base64 encoded strings, each representing a PDF file.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional parameters to include in the request payload, such as systemInstruction or generationConfig.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; response = gemini_hook.generate_content_with_pdf(\n...     model=\"gemini-2.5-pro\",\n...     prompt=\"Summarize this article about climate change...\",\n...     pdf_files=[base64_pdf1, base64_pdf2],\n...     systemInstruction={\"parts\": [{\"text\": \"You are an expert summarizer. Provide a concise summary.\"}]},\n...     generationConfig={\"responseMimeType\": \"text/plain\", \"temperature\": 0.2}\n... )\n</code></pre> <p>Example with custom contents structure</p> <pre><code>&gt;&gt;&gt; response = gemini_hook.generate_content_with_pdf(\n...     model=\"gemini-2.5-pro\",\n...     pdf_files=[base64_pdf1, base64_pdf2],\n...     systemInstruction={\"parts\": [{\"text\": \"You are an expert summarizer. Provide a concise summary.\"}]},\n...     generationConfig={\"responseMimeType\": \"text/plain\", \"temperature\": 0.2}\n... )\n</code></pre> <p>Returns:</p> Type Description <code>dict</code> <p>The full JSON response from the Gemini API as a dictionary.</p>"},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.VertexAiHook","title":"<code>VertexAiHook</code>","text":"<p>               Bases: <code>LLMHook</code></p> <p>Hook for interacting with Vertex AI Generative Models.</p>"},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.VertexAiHook.__init__","title":"<code>__init__(model_name: str, **kwargs: dict[str, Any]) -&gt; None</code>","text":"<p>Initializes the GenerativeModelHook.</p> Note <p>Requires the following environment variables to be set:</p> <ul> <li>GCP_PROJECT: The Google Cloud project ID.</li> <li>GCP_REGION: The Google Cloud region.</li> </ul> <p>These are needed to initialize the Vertex AI client with the correct context.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model to use.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for model initialization.</p> <code>{}</code>"},{"location":"api/airless-google-cloud-vertexai/hook/#airless.google.cloud.vertexai.hook.VertexAiHook.generate_content","title":"<code>generate_content(content: str, **kwargs: dict[str, Any]) -&gt; Any</code>","text":"<p>Generates a content for the given content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to generate a content for.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the generation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The generated content.</p>"},{"location":"api/airless-pdf/hook/","title":"hook","text":""},{"location":"api/airless-pdf/hook/#airless.pdf.hook","title":"<code>hook</code>","text":""},{"location":"api/airless-pdf/hook/#airless.pdf.hook.__all__","title":"<code>__all__ = ['PDFHook']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-pdf/hook/#airless.pdf.hook.PDFHook","title":"<code>PDFHook</code>","text":"<p>               Bases: <code>BaseHook</code></p> <p>Hook for handling PDF operations.</p>"},{"location":"api/airless-pdf/hook/#airless.pdf.hook.PDFHook.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the PDFHook.</p>"},{"location":"api/airless-pdf/hook/#airless.pdf.hook.PDFHook.chunk_in_pages","title":"<code>chunk_in_pages(filepath: str, pages_per_chunk: int) -&gt; List[str]</code>","text":"<p>Splits the PDF into chunks with a specified number of pages per chunk.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the PDF file.</p> required <code>pages_per_chunk</code> <code>int</code> <p>Number of pages per chunk.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of file paths to the chunked PDF files.</p>"},{"location":"api/airless-pdf/hook/#airless.pdf.hook.PDFHook.generate_page_screenshot","title":"<code>generate_page_screenshot(filepath: str, dpi: int = 300, output_format: str = 'png') -&gt; List[str]</code>","text":"<p>Converts each page of a PDF into an image.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The file path to the PDF.</p> required <code>dpi</code> <code>int</code> <p>Dots per inch for the output image. Defaults to 300.</p> <code>300</code> <code>output_format</code> <code>str</code> <p>The format of the output images (e.g., 'png', 'jpg'). Defaults to 'png'.</p> <code>'png'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of file paths to the generated images.</p>"},{"location":"api/airless-slack/operator/","title":"operator","text":""},{"location":"api/airless-slack/operator/#airless.slack.operator","title":"<code>operator</code>","text":""},{"location":"api/airless-slack/operator/#airless.slack.operator.__all__","title":"<code>__all__ = ['SlackSendOperator', 'SlackReactOperator', 'GoogleSlackSendOperator', 'GoogleSlackReactOperator']</code>  <code>module-attribute</code>","text":""},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator","title":"<code>GoogleSlackReactOperator</code>","text":"<p>               Bases: <code>SlackReactOperator</code>, <code>GoogleBaseEventOperator</code></p> <p>Slack operator using Google Secret Manager to get secrets.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GoogleSlackReactOperator.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator.execute","title":"<code>execute(data: Dict[str, Any], topic: str) -&gt; None</code>","text":"<p>Executes the reaction to a Slack message.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data containing reaction information.</p> required <code>topic</code> <code>str</code> <p>The Pub/Sub topic.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackReactOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator","title":"<code>GoogleSlackSendOperator</code>","text":"<p>               Bases: <code>SlackSendOperator</code>, <code>GoogleBaseEventOperator</code></p> <p>Slack operator using Google Secret Manager to get secrets.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the GoogleSlackSendOperator.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator.execute","title":"<code>execute(data: Dict[str, Any], topic: str) -&gt; None</code>","text":"<p>Executes the sending of messages to Slack.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data containing message information.</p> required <code>topic</code> <code>str</code> <p>The Pub/Sub topic.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.GoogleSlackSendOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator","title":"<code>SlackReactOperator</code>","text":"<p>               Bases: <code>BaseEventOperator</code></p> <p>Operator for reacting to Slack messages.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the SlackReactOperator.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator.execute","title":"<code>execute(data: Dict[str, Any], topic: str) -&gt; None</code>","text":"<p>Executes the reaction to a Slack message.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data containing reaction information.</p> required <code>topic</code> <code>str</code> <p>The Pub/Sub topic.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackReactOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator","title":"<code>SlackSendOperator</code>","text":"<p>               Bases: <code>BaseEventOperator</code></p> <p>Operator for sending messages to Slack.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initializes the SlackSendOperator.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator.build_error_message","title":"<code>build_error_message(message: str, data: dict) -&gt; dict</code>","text":"<p>Builds an error message specific to event operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>data</code> <code>dict</code> <p>The associated data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A constructed error message.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator.chain_messages","title":"<code>chain_messages(messages: list) -&gt; tuple</code>","text":"<p>Chains messages together for processing.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list</code> <p>A list of messages to chain.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing chained message data and the first topic.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator.execute","title":"<code>execute(data: Dict[str, Any], topic: str) -&gt; None</code>","text":"<p>Executes the sending of messages to Slack.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data containing message information.</p> required <code>topic</code> <code>str</code> <p>The Pub/Sub topic.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator.extract_message_id","title":"<code>extract_message_id(cloud_event) -&gt; str</code>","text":"<p>Extracts the message ID from the cloud event.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event from which to extract the message ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted message ID.</p>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator.report_error","title":"<code>report_error(message: str, data: dict = None)</code>","text":"<p>Reports an error by logging it and publishing to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to report.</p> required <code>data</code> <code>dict</code> <p>Additional data associated with the error. Defaults to None.</p> <code>None</code>"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator.run","title":"<code>run(cloud_event) -&gt; None</code>","text":"<p>Processes the incoming cloud event and executes event logic.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_event</code> <code>CloudEvent</code> <p>The cloud event containing metadata about the event.</p> required"},{"location":"api/airless-slack/operator/#airless.slack.operator.SlackSendOperator.run_next","title":"<code>run_next(tasks: list) -&gt; None</code>","text":"<p>Executes the next tasks in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>A list of tasks to execute next.</p> required"},{"location":"tutorials/multistep/","title":"Multi Step Workflow","text":"<p>This quickstart guides you through setting up a workflow that involves multiple steps: first, retrieving the latitude and longitude for a given city name, and second, using those coordinates to fetch the current temperature. This workflow consults two different APIs and logs the results. We will run this locally using the terminal.</p>"},{"location":"tutorials/multistep/#project-structure","title":"Project Structure","text":"<p>You will need to create the following structure:</p> <pre><code>.\n\u251c\u2500\u2500 hook\n\u2502   \u2514\u2500\u2500 api.py\n\u251c\u2500\u2500 operator\n\u2502   \u2514\u2500\u2500 weather.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 .env\n</code></pre> <p>Create the hook and operator folders like this:</p> <pre><code>mkdir hook operator\n</code></pre>"},{"location":"tutorials/multistep/#workflow-sequence-diagram","title":"Workflow Sequence Diagram","text":"<p>The following diagram illustrates the interaction between the components when a request is processed by the <code>WeatherOperator</code>.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant Client\n    participant WeatherOperator\n    participant ApiHook\n    participant GeocodeAPI\n    participant WeatherAPI\n    participant Logger\n\n    Client-&gt;&gt;WeatherOperator: execute(data, topic)\n    Note right of WeatherOperator: 1. Start processing request.\n    WeatherOperator-&gt;&gt;WeatherOperator: Determine request_type from data\n    Note right of WeatherOperator: 2. Check if 'city_lat_long' or 'temperature'.\n    WeatherOperator-&gt;&gt;ApiHook: __init__()\n    Note right of WeatherOperator: 3. Instantiate the ApiHook.\n\n    alt request_type == 'city_lat_long'\n        WeatherOperator-&gt;&gt;WeatherOperator: get_city_lat_long(data, topic)\n        Note right of WeatherOperator: 4a. Route to coordinate fetching method.\n        WeatherOperator-&gt;&gt;ApiHook: get_lat_long_from_city(city_name)\n        Note right of ApiHook: 5a. Request coordinates for the city.\n        ApiHook-&gt;&gt;GeocodeAPI: GET /city_name?json=1\n        Note right of ApiHook: 6a. Call geocode.xyz API.\n        GeocodeAPI--&gt;&gt;ApiHook: latitude, longitude response\n        ApiHook-&gt;&gt;Logger: Log debug response\n        Note right of ApiHook: 7a. Log the raw API response (if DEBUG level).\n        ApiHook--&gt;&gt;WeatherOperator: return latitude, longitude\n        Note right of WeatherOperator: 8a. Receive coordinates.\n        WeatherOperator-&gt;&gt;Logger: Log info result\n        Note right of WeatherOperator: 9a. Log successfully fetched coordinates.\n\n    else request_type == 'temperature'\n        WeatherOperator-&gt;&gt;WeatherOperator: get_temperature(data, topic)\n        Note right of WeatherOperator: 4b. Route to temperature fetching method.\n        WeatherOperator-&gt;&gt;ApiHook: get_temperature(lat, lon)\n        Note right of ApiHook: 5b. Request temperature for coordinates.\n        ApiHook-&gt;&gt;WeatherAPI: GET /forecast?latitude=...&amp;longitude=...&amp;current=temperature_2m\n        Note right of ApiHook: 6b. Call open-meteo API.\n        WeatherAPI--&gt;&gt;ApiHook: temperature response\n        ApiHook-&gt;&gt;Logger: Log debug response\n        Note right of ApiHook: 7b. Log the raw API response (if DEBUG level).\n        ApiHook--&gt;&gt;WeatherOperator: return temperature\n        Note right of WeatherOperator: 8b. Receive temperature.\n        WeatherOperator-&gt;&gt;Logger: Log info result\n        Note right of WeatherOperator: 9b. Log successfully fetched temperature.\n\n    else Invalid request_type\n        WeatherOperator-&gt;&gt;Logger: Log error\n        Note right of WeatherOperator: Handle unknown request type.\n    end\n</code></pre> <p>Explanation of Steps:</p> <ol> <li>Start Processing Request: A client (like the <code>make</code> command via <code>uv run</code>) initiates the workflow by calling the <code>execute</code> method of the <code>WeatherOperator</code>, passing input <code>data</code> (containing <code>request_type</code> and other necessary parameters like <code>city_name</code> or <code>lat</code>/<code>lon</code>) and a <code>topic</code>.</li> <li>Determine Request Type: The <code>WeatherOperator</code> reads the <code>request_type</code> field from the input <code>data</code> to decide which specific task to perform.</li> <li>Instantiate ApiHook: The <code>WeatherOperator</code> creates an instance of the <code>ApiHook</code> to gain access to its methods for interacting with external APIs.</li> <li>Route Request:<ul> <li>(4a) If <code>request_type</code> is <code>'city_lat_long'</code>, the <code>execute</code> method calls the internal <code>get_city_lat_long</code> method.</li> <li>(4b) If <code>request_type</code> is <code>'temperature'</code>, the <code>execute</code> method calls the internal <code>get_temperature</code> method.</li> </ul> </li> <li>Call Hook Method:<ul> <li>(5a) <code>get_city_lat_long</code> calls the <code>ApiHook</code>'s <code>get_lat_long_from_city</code> method, passing the <code>city_name</code>.</li> <li>(5b) <code>get_temperature</code> calls the <code>ApiHook</code>'s <code>get_temperature</code> method, passing the <code>lat</code> and <code>lon</code>.</li> </ul> </li> <li>Interact with External API:<ul> <li>(6a) The <code>ApiHook</code> sends an HTTP GET request to the <code>geocode.xyz</code> API endpoint to retrieve coordinates for the given city.</li> <li>(6b) The <code>ApiHook</code> sends an HTTP GET request to the <code>open-meteo</code> API endpoint to retrieve the current temperature for the given coordinates.</li> </ul> </li> <li>Log API Response (Debug): If the <code>LOG_LEVEL</code> is set to <code>DEBUG</code>, the <code>ApiHook</code> logs the raw JSON response received from the external API for debugging purposes.</li> <li>Return Result to Operator:<ul> <li>(8a) The <code>ApiHook</code> parses the response from <code>geocode.xyz</code> and returns the extracted latitude and longitude to the <code>WeatherOperator</code>.</li> <li>(8b) The <code>ApiHook</code> parses the response from <code>open-meteo</code> and returns the extracted temperature to the <code>WeatherOperator</code>.</li> </ul> </li> <li>Log Final Result (Info):<ul> <li>(9a) The <code>WeatherOperator</code> logs the successfully retrieved coordinates at the <code>INFO</code> level.</li> <li>(9b) The <code>WeatherOperator</code> logs the successfully retrieved temperature at the <code>INFO</code> level.</li> </ul> </li> </ol> <p>If the <code>request_type</code> is not recognized, the <code>WeatherOperator</code> logs an error message.</p>"},{"location":"tutorials/multistep/#hookpy","title":"hook.py","text":"<p>We will create a hook that interacts with two external APIs: 1.  geocode.xyz: To get latitude and longitude from a city name. 2.  open-meteo: To get the current weather using latitude and longitude.</p> hook/api.py<pre><code>import requests\nfrom urllib.parse import quote\nfrom typing import Tuple, Dict, Any\n\nfrom airless.core.hook import BaseHook\n\n\nclass ApiHook(BaseHook): # (1)!\n    \"\"\"A hook to fetch geocode data and weather information.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the ApiHook.\"\"\"\n        super().__init__()\n        self.weather_base_url = 'https://api.open-meteo.com/v1/forecast'\n        self.geocode_base_url = 'https://geocode.xyz'\n\n    def _get_geocode_headers(self) -&gt; Dict[str, str]: # (2)!\n        \"\"\"Returns headers needed for the geocode.xyz API request.\"\"\"\n        return {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36',\n            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',\n            'accept-language': 'en-US,en;q=0.9', # Changed to en-US for broader compatibility\n            'cache-control': 'no-cache',\n            'pragma': 'no-cache',\n            'priority': 'u=0, i',\n            'sec-ch-ua': '\"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-fetch-dest': 'document',\n            'sec-fetch-mode': 'navigate',\n            'sec-fetch-site': 'none',\n            'sec-fetch-user': '?1',\n            'upgrade-insecure-requests': '1',\n        }\n\n    def get_lat_long_from_city(self, city_name: str) -&gt; Tuple[float, float]: # (3)!\n        \"\"\"\n        Fetch the latitude and longitude for a given city name using geocode.xyz.\n\n        Args:\n            city_name (str): The name of the city.\n\n        Returns:\n            Tuple[float, float]: A tuple containing latitude and longitude.\n\n        Raises:\n            requests.exceptions.RequestException: If the API request fails.\n            KeyError: If the expected keys ('latt', 'longt') are not in the response.\n        \"\"\"\n        url = f\"{self.geocode_base_url}/{quote(city_name)}?json=1\"\n        headers = self._get_geocode_headers()\n\n        with requests.Session() as session:\n            response = session.get(url, headers=headers)\n            response.raise_for_status() # (4)!\n            data = response.json()\n            self.logger.debug(f\"Geocode response data: {data}\")\n\n            latitude = float(data['latt'])\n            longitude = float(data['longt'])\n\n            return latitude, longitude\n\n    def get_temperature(self, lat: float, lon: float) -&gt; float: # (5)!\n        \"\"\"\n        Fetch the current temperature for given latitude and longitude using Open-Meteo.\n\n        Args:\n            lat (float): The latitude.\n            lon (float): The longitude.\n\n        Returns:\n            float: The current temperature in Celsius.\n\n        Raises:\n            requests.exceptions.RequestException: If the API request fails.\n            KeyError: If the expected keys are not in the response.\n        \"\"\"\n        params = {\n            'latitude': lat,\n            'longitude': lon,\n            'current': 'temperature_2m'\n        }\n        with requests.Session() as session: # (6)!\n            response = session.get(\n                self.weather_base_url,\n                params=params\n            )\n            response.raise_for_status() # (4)!\n            data = response.json()\n            self.logger.debug(f\"Weather response data: {data}\")\n\n            temperature = data['current']['temperature_2m']\n\n            return temperature\n</code></pre> <ol> <li>To create a hook, inherit from <code>BaseHook</code>.</li> <li>We separate the header generation for the <code>geocode.xyz</code> API into its own method <code>_get_geocode_headers</code> for clarity and potential reuse.</li> <li>The <code>get_lat_long_from_city</code> method takes a city name, constructs the URL for <code>geocode.xyz</code>, calls the API using the headers from <code>_get_geocode_headers</code>, parses the JSON response, and returns the latitude and longitude. It includes basic error handling for empty city names and missing keys in the response.</li> <li>Use <code>response.raise_for_status()</code> to raise an HTTPError for bad responses (4xx or 5xx). This helps in catching API errors early.</li> <li>The <code>get_temperature</code> method remains similar, taking latitude and longitude to query the Open-Meteo API for the current temperature. Error handling for the response structure is added.</li> <li>Use <code>requests.Session()</code> to manage connections efficiently and ensure resources are properly closed.</li> </ol>"},{"location":"tutorials/multistep/#operatorpy","title":"operator.py","text":"<p>Now, we create an operator that uses the <code>ApiHook</code>. This operator will handle two types of requests: one to get the latitude and longitude for a city, and another to get the temperature using provided latitude and longitude.</p> operator/weather.py<pre><code>from airless.core.operator import BaseOperator\n\nfrom hook.api import ApiHook\n\n\nclass WeatherOperator(BaseOperator): # (1)!\n    \"\"\"\n    An operator to fetch geographic coordinates for a city\n    or weather data using coordinates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the WeatherOperator.\"\"\"\n        super().__init__()\n        self.api_hook = ApiHook()\n\n    def execute(self, data: dict, topic: str) -&gt; None: # (2)!\n        \"\"\"\n        Routes the request to the appropriate method based on 'request_type'.\n        \"\"\"\n        request_type = data['request_type']\n\n        if request_type == 'temperature':\n            self.get_temperature(data, topic)\n        elif request_type == 'city_lat_long':\n            self.get_city_lat_long(data, topic)\n        else:\n            self.logger.error(f\"Request type '{request_type}' not implemented or missing.\")\n\n    def get_city_lat_long(self, data: dict, topic: str) -&gt; None: # (4)!\n        \"\"\"Fetch the latitude and longitude for a given city name.\"\"\"\n        city_name = data['city_name']\n\n        latitude, longitude = self.api_hook.get_lat_long_from_city(city_name)\n        self.logger.info(f\"Successfully fetched coordinates for city: {city_name}.\") # (3)!\n        self.logger.info(f\"Coordinates for {city_name}: Latitude={latitude}, Longitude={longitude}\")\n\n    def get_temperature(self, data: dict, topic: str) -&gt; None:\n        \"\"\"Fetch the current temperature for given coordinates.\"\"\"\n        lat = data['lat']\n        lon = data['lon']\n\n        temperature = self.api_hook.get_temperature(lat, lon)\n        self.logger.info(f\"Successfully fetched temperature for ({lat}, {lon}).\") # (3)!\n        self.logger.info(f\"Temperature at ({lat}, {lon}): {temperature}\u00b0C\")\n</code></pre> <ol> <li>To create an operator, inherit from <code>BaseOperator</code>.</li> <li>The <code>execute</code> method acts as a router. It checks the <code>request_type</code> field in the input <code>data</code> dictionary and calls the corresponding method (<code>get_temperature</code> or <code>get_city_lat_long</code>).</li> <li><code>BaseOperator</code> provides a built-in <code>self.logger</code> for logging messages.</li> <li>The new <code>get_city_lat_long</code> method extracts the <code>city_name</code> from the data, calls the corresponding hook method (<code>get_lat_long_from_city</code>), and logs the result or any errors encountered. Basic validation for the presence of <code>city_name</code> is added.</li> </ol>"},{"location":"tutorials/multistep/#makefile-and-env","title":"Makefile and .env","text":"<p>In the root directory create a <code>Makefile</code> and a <code>.env</code> file.</p> <p>First, create the files: <pre><code>touch Makefile .env\n</code></pre></p> <p>In the <code>Makefile</code>, add commands to run both types of requests:</p> Warning <p>Makefile indentation must use tabs, not spaces.</p> <pre><code>run-temp:\n    @python -c \"from operator.weather import WeatherOperator; WeatherOperator().execute(data={'request_type': 'temperature', 'lat': 40.7128, 'lon': -74.0060}, topic='test-topic')\"\n\nrun-latlong:\n    @python -c \"from operator.weather import WeatherOperator; WeatherOperator().execute(data={'request_type': 'city_lat_long', 'city_name': 'New York'}, topic='test-topic')\"\n</code></pre> <p>In the <code>.env</code> file, add the following environment variables:</p> <p>.env<pre><code>ENV=dev\nLOG_LEVEL=DEBUG\n</code></pre> Setting <code>LOG_LEVEL=DEBUG</code> will ensure you see the detailed logs from the hook and operator, including API responses. Change to <code>INFO</code> for less verbose output.</p>"},{"location":"tutorials/multistep/#run","title":"Run","text":"<p>To run the operator for a specific task, use the corresponding <code>make</code> target. <code>uv run</code> handles loading the <code>.env</code> file automatically. If not using <code>uv</code>, ensure environment variables are exported or use a library like <code>python-dotenv</code>.</p> <p>To get coordinates for a city (e.g., New York): <pre><code>uv run --env-file .env make run-latlong\n</code></pre></p> <p>To get the temperature for specific coordinates (e.g., New York's approx. coordinates): <pre><code>uv run --env-file .env make run-temp\n</code></pre></p> <p>You should see log output in your terminal showing the API calls and the results (coordinates or temperature), or error messages if something went wrong.</p>"},{"location":"tutorials/quickstart/","title":"Quickstart Workflow","text":"<p>This quickstart guides you through installing the <code>airless-core</code> package, setting up a basic workflow that consult an api and log the response. This will running it locally either in the terminal.</p> <p>This quickstart assumes a local IDE (VS Code, PyCharm, etc.) with Python 3.9+ and terminal access. This method runs the application entirely on your machine and is recommended for internal development.</p>"},{"location":"tutorials/quickstart/#set-up-environment-install-airless-needed-packages","title":"Set up Environment &amp; Install airless needed packages","text":"<p>Create environment and install airless-core:</p> uvpip + venv <pre><code>uv init --bare --no-workspace\nuv add airless-core\n</code></pre> <pre><code>python -m venv .venv\n# Activate venv in Mac / Linux\nsource .venv/bin/activate\n# Windows CMD: .venv\\Scripts\\activate.bat\n# Windows PowerShell: .venv\\Scripts\\Activate.ps1\npip install airless-core\n</code></pre>"},{"location":"tutorials/quickstart/#project-structure","title":"Project Structure","text":"<p>You will need to create the following structure:</p> <pre><code>.\n\u251c\u2500\u2500 hook\n\u2502   \u2514\u2500\u2500 api.py\n\u251c\u2500\u2500 operator\n\u2502   \u2514\u2500\u2500 weather.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 .env\n</code></pre> <p>Create the hook and operator folders like this</p> <pre><code>mkdir hook operator\n</code></pre> <p>In <code>.env</code> file you need to add the following env vars</p> <p>Note</p> <p>If you're using uv you can pass the <code>.env</code> file when executing the code using the following code <code>uv run --env-file .env python ...</code>. If you're not using uv you can export this variables to you're current terminal session.</p>"},{"location":"tutorials/quickstart/#workflow-sequence-diagram","title":"Workflow Sequence Diagram","text":"<p>The interaction between the components when running the <code>make run</code> command follows this sequence:</p> <pre><code>sequenceDiagram\n    autonumber\n    participant Caller\n    participant WeatherOp as WeatherOperator\n    participant ApiHook as ApiHook\n    participant OpenMeteo as Open-Meteo API\n\n    Caller-&gt;&gt;WeatherOp: execute(data={'request_type': 'temperature', ...})\n    WeatherOp-&gt;&gt;WeatherOp: Check data['request_type']\n    WeatherOp-&gt;&gt;WeatherOp: Call self.get_temperature(data, topic)\n    WeatherOp-&gt;&gt;ApiHook: get_temperature(lat, lon)\n    ApiHook-&gt;&gt;OpenMeteo: GET /v1/forecast?latitude=...&amp;longitude=...&amp;current=temperature_2m\n    OpenMeteo--&gt;&gt;ApiHook: JSON Response { current: { temperature_2m: T } }\n    ApiHook-&gt;&gt;ApiHook: Check response status (raise_for_status)\n    ApiHook-&gt;&gt;ApiHook: Parse JSON and extract temperature\n    Note right of ApiHook: Logs full response (DEBUG level)\n    ApiHook--&gt;&gt;WeatherOp: Return temperature (T)\n    Note right of WeatherOp: Logs received temperature (DEBUG level)\n    WeatherOp--&gt;&gt;Caller: Execution completes</code></pre> <p>Explanation of the Diagram Steps:</p> <ol> <li>Caller -&gt; WeatherOperator: execute(...)     An external system or caller invokes the <code>execute</code> method of an existing <code>WeatherOperator</code> instance (defined in <code>operator/weather.py</code>), providing the necessary data payload. When the <code>WeatherOperator</code> was instantiated (outside this sequence), it also created an instance of <code>ApiHook</code> (from <code>hook/api.py</code>).</li> <li>WeatherOperator -&gt; WeatherOperator: Check data['request_type']     Inside the <code>execute</code> method, the operator examines the <code>request_type</code> field within the provided <code>data</code> dictionary to decide the next action.</li> <li>WeatherOperator -&gt; WeatherOperator: Call self.get_temperature(data, topic)     As the <code>request_type</code> is 'temperature', the <code>execute</code> method proceeds to call the operator's own <code>get_temperature</code> method, passing the data.</li> <li>WeatherOperator -&gt; ApiHook: get_temperature(lat, lon)     The operator's <code>get_temperature</code> method retrieves the latitude (<code>lat</code>) and longitude (<code>lon</code>) from the data and invokes the <code>get_temperature</code> method on its associated <code>ApiHook</code> instance.</li> <li>ApiHook -&gt; Open-Meteo API: GET /v1/forecast...     The <code>ApiHook</code> formulates the request parameters and dispatches an HTTP GET request to the Open-Meteo API endpoint via the <code>requests</code> library, aiming to retrieve the current temperature for the specified coordinates.</li> <li>Open-Meteo API --&gt;&gt; ApiHook: JSON Response {...}     The Open-Meteo API fulfills the request and returns a JSON formatted response containing the weather details, including the temperature data.</li> <li>ApiHook -&gt; ApiHook: Check response status (raise_for_status)     The hook validates the HTTP response status. If it indicates an error (e.g., 4xx or 5xx status code), an exception is raised. Otherwise, processing continues.</li> <li>ApiHook -&gt; ApiHook: Parse JSON and extract temperature     The hook processes the successful JSON response, navigating its structure to isolate the specific temperature value (<code>temperature_2m</code>). The complete response is also logged at the DEBUG level for diagnostics.</li> <li>ApiHook --&gt;&gt; WeatherOperator: Return temperature (T)     The extracted temperature value is sent back as the return value from <code>ApiHook.get_temperature</code> to the waiting <code>WeatherOperator</code>.</li> <li>WeatherOperator: Logs received temperature (DEBUG level)     Upon receiving the temperature from the hook, the <code>WeatherOperator.get_temperature</code> method logs this value using its configured logger.</li> <li>WeatherOperator --&gt;&gt; Caller: Execution completes     With the temperature fetched and logged, the <code>get_temperature</code> and subsequently the <code>execute</code> methods complete their execution, returning control flow back to the original <code>Caller</code>.</li> </ol>"},{"location":"tutorials/quickstart/#hookpy","title":"hook.py","text":"<p>We will use the open-meteo api to get the current weather giving a latitude and longitude.</p> hook/api.py<pre><code>import requests\n\nfrom airless.core.hook import BaseHook\n\n\nclass ApiHook(BaseHook):# (1)!\n    \"\"\"A simple hook to simulate fetching weather data.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the WeatherApiHook.\"\"\"\n        super().__init__()\n        self.base_url = 'https://api.open-meteo.com/v1/forecast'\n\n    def get_temperature(self, lat: float, lon: float) -&gt; float:\n        \"\"\"\n        Fetch the current temperature for a given city.\n\n        Args:\n            lat (float): The latitude of the city.\n            lon (float): The longitude of the city.\n\n        Returns:\n            float: The current temperature in Celsius.\n\n        Raises:\n            ValueError: If the latitude or longitude is empty or invalid.\n        \"\"\"\n        params = {\n            'latitude': lat,\n            'longitude': lon,\n            'current': 'temperature_2m' \n        }\n        with requests.Session() as session:# (2)!\n            response = session.get(\n                self.base_url,\n                params=params\n            )\n            response.raise_for_status()# (3)!\n            data = response.json()\n            self.logger.debug(f\"Response: {data}\")\n\n            temperature = data['current']['temperature_2m']\n\n            return temperature\n</code></pre> <ol> <li>To create a hook you need to inherit from <code>BaseHook</code></li> <li>Use <code>requests.Session()</code> to ensure that the session is closed after the request, to avoid memory leaks.</li> <li>Use <code>response.raise_for_status()</code> to raise an exception if the request was not successful. Depends on the use case, is better to raise an exception so can be caught, retried and handled by the operator or by the airless error function.</li> </ol>"},{"location":"tutorials/quickstart/#operatorpy","title":"operator.py","text":"<p>Now we will create a operator that will use the hook we just created. operator/weather.py<pre><code>from airless.core.operator import BaseOperator\n\nfrom hook.api import ApiHook\n\n\nclass WeatherOperator(BaseOperator):# (1)!\n    \"\"\"A simple operator to simulate fetching weather data.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the WeatherOperator.\"\"\"\n        super().__init__()\n        self.api_hook = ApiHook()\n\n    def execute(self, data: dict, topic: str) -&gt; None:\n        \"\"\"Define which method to call based on the request type.\"\"\"\n        request_type = data['request_type'] # (2)!\n\n        if request_type == 'temperature':\n            self.get_temperature(data, topic)\n        else:\n            raise Exception(f'Request type {request_type} not implemented')\n\n    def get_temperature(self, data: dict, topic: str) -&gt; None:\n        \"\"\"Fetch the current temperature for a given city.\"\"\"\n        lat = data['lat']\n        lon = data['lon']\n        temperature = self.api_hook.get_temperature(lat, lon)\n\n        self.logger.debug(f\"Temperature: {temperature}\") # (3)!\n</code></pre></p> <ol> <li>To create an operator you need to inherit from <code>BaseOperator</code></li> <li>In general, in execute method you need to define which method to call based on the request type.</li> <li><code>BaseOperator</code> has a built-in <code>self.logger</code> to log messages.</li> </ol>"},{"location":"tutorials/quickstart/#makefile-and-env","title":"Makefile and .env","text":"<p>In the root directory create a <code>Makefile</code> and a <code>.env</code> file.</p> <p>First, to create the files run the command: <pre><code>touch Makefile .env\n</code></pre></p> <p>In the <code>Makefile</code> add the following code:</p> Warning <p>Makefile identation is tab not spaces</p> <pre><code>run:\n    @python -c \"from operator.weather import WeatherOperator; WeatherOperator().execute(request={'data': {'request_type': 'temperature', 'lat': 40.7128, 'lon': -74.0060}})\"\n</code></pre> Exporting environment variables in Makefile <p>If you want you can export your environment variables in the Makefile. But it's not recommended.</p> <p>Just need to write like the following code: <pre><code>export ENV=dev\nexport LOG_LEVEL=DEBUG\n\nrun:\n    @python -c \"from operator.weather import WeatherOperator; WeatherOperator().execute(request={'data': {'request_type': 'temperature', 'lat': 40.7128, 'lon': -74.0060}})\"\n</code></pre></p> <p>In <code>.env</code> add the following environment variables:</p> <pre><code>ENV=dev\nLOG_LEVEL=DEBUG\n</code></pre>"},{"location":"tutorials/quickstart/#run","title":"Run","text":"<p>To run the operator you just need to execute the following command:</p> <pre><code>uv run --env-file .env make run\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/","title":"Core Infrastructure","text":""},{"location":"tutorials/gcp/core-infrastructure/#building-airless-core-infrastructure-on-gcp-with-terraform","title":"Building Airless Core Infrastructure on GCP with Terraform","text":"<p>This guide explains how to set up the essential GCP resources for an Airless workflow orchestrator using Terraform. Airless leverages serverless functions and message queues to create scalable, event-driven workflows.</p>"},{"location":"tutorials/gcp/core-infrastructure/#why-use-google-cloud-functions-in-airless","title":"Why Use Google Cloud Functions in Airless?","text":"<p>Airless is designed around a serverless, event-driven architecture. Google Cloud Functions are a natural fit for this model in GCP for several reasons outlined in the Airless philosophy:</p> <ol> <li>Serverless: Cloud Functions eliminate the need to manage underlying servers or infrastructure. You only pay for execution time, which is cost-effective, especially for workflows that aren't running constantly. This aligns with Airless's goal to avoid the fixed costs and management overhead of traditional orchestrators like a dedicated Airflow instance.</li> <li>Scalability: Cloud Functions automatically scale based on the incoming event load (e.g., messages in a Pub/Sub topic). This handles the \"massive parallel processing\" requirement mentioned for Airless, particularly for use cases like data scraping where the number of tasks can vary dramatically and unpredictably.</li> <li>Event-Driven: Functions are triggered by events, such as messages published to a Pub/Sub topic or HTTP requests. This fits perfectly with Airless's data flow where tasks trigger subsequent tasks by publishing messages.</li> <li>Decoupling: Using functions triggered by queues (Pub/Sub) decouples different stages of a workflow. Each function performs a specific task and communicates with others via messages, enhancing resilience and modularity.</li> </ol>"},{"location":"tutorials/gcp/core-infrastructure/#why-use-terraform","title":"Why Use Terraform?","text":"<p>Terraform is an Infrastructure as Code (IaC) tool used to define and provision infrastructure resources across various cloud providers, including GCP. Using Terraform for Airless offers significant advantages:</p> <ol> <li>Reproducibility &amp; Consistency: Define your entire Airless infrastructure (Functions, Pub/Sub topics, Storage Buckets, etc.) in configuration files. This ensures you can create identical environments (dev, staging, prod) consistently.</li> <li>Version Control: Store your infrastructure configuration in version control systems (like Git). Track changes, collaborate with others, and roll back to previous states if needed.</li> <li>Automation: Automate the provisioning and management of your GCP resources, reducing manual effort and the potential for human error.</li> <li>Modularity: Break down your infrastructure into reusable modules (as demonstrated in the provided code), making configurations easier to manage and scale.</li> <li>State Management: Terraform keeps track of the resources it manages in a state file, allowing it to understand dependencies and manage updates or deletions safely.</li> </ol>"},{"location":"tutorials/gcp/core-infrastructure/#the-need-for-_raw-storage","title":"The Need for <code>_raw</code> Storage","text":"<p>In data processing pipelines like those often built with Airless, it's crucial to have intermediate storage layers. The <code>_raw</code> storage bucket (e.g., <code>${var.env}-datalake-raw</code> in <code>storage.tf</code>) serves several key purposes:</p> <ol> <li>Error Handling &amp; Debugging: When a function fails processing a message, the original message data and error details can be stored in the <code>_raw</code> bucket (or a dedicated error location). This prevents data loss and allows for later analysis and reprocessing. The Error function often coordinates this.</li> <li>Data Staging: Functions might fetch data that needs to be temporarily stored before being processed by a subsequent task or loaded into a final destination. The <code>_raw</code> or <code>_landing_tmp</code> buckets act as these staging areas.</li> <li>Auditing &amp; Compliance: Storing raw incoming data or intermediate results can be necessary for auditing or compliance purposes.</li> <li>Decoupling Processing: Allows tasks to deposit data without needing immediate processing by the next step, further decoupling the workflow.</li> </ol> <p>The provided <code>storage.tf</code> also includes lifecycle rules to transition older data to cheaper storage classes (like ARCHIVE), managing costs effectively.</p>"},{"location":"tutorials/gcp/core-infrastructure/#terraform-module-structure","title":"Terraform Module Structure","text":"<p>The provided Terraform code is structured as a module. This is a best practice in Terraform that promotes reusability and organization. A module is a self-contained package of Terraform configurations that manages a set of related resources.</p> <ul> <li>Inputs: The module defines input variables (<code>variables.tf</code>) like <code>project_id</code>, <code>region</code>, <code>env</code>, etc. This allows users of the module to customize the deployment without modifying the core code.</li> <li>Resources: The module contains the resource definitions (<code>.tf</code> files like <code>error.tf</code>, <code>delay.tf</code>, <code>storage.tf</code>, etc.) that create the actual infrastructure (Cloud Functions, Pub/Sub topics, GCS buckets).</li> <li>Outputs: The module defines outputs (<code>output.tf</code>) like bucket names and Pub/Sub topic names/IDs. These outputs expose key information about the created resources, which can be used by other Terraform configurations or for reference.</li> </ul> <p>By using a module, you can easily deploy this core Airless infrastructure multiple times (e.g., for different environments or projects) with different configurations by simply calling the module and providing the appropriate input variables.</p>"},{"location":"tutorials/gcp/core-infrastructure/#terraform-project-setup-backendtf-etc","title":"Terraform Project Setup (<code>backend.tf</code>, etc.)","text":"<p>When using Terraform, you typically organize your code into several files. While the provided code represents a module, a typical Terraform project using this module would also include:</p> <ol> <li><code>main.tf</code> (Root): This file would define the provider (Google Cloud) and call the Airless core module, passing the required input variables.</li> <li><code>variables.tf</code> (Root): Defines variables for the root configuration (potentially passing them down to the module).</li> <li><code>outputs.tf</code> (Root): Defines outputs for the overall deployment (potentially exposing module outputs).</li> <li><code>backend.tf</code>: This crucial file configures Terraform's state management. It tells Terraform where to store the state file, which tracks the resources managed by the configuration. Using a remote backend (like a GCS bucket) is highly recommended for collaboration and consistency.</li> </ol> Example <code>backend.tf</code> and Root <code>main.tf</code> <p><code>backend.tf</code> <pre><code>terraform {\n  backend \"gcs\" {\n    bucket = \"your-terraform-state-bucket-name\" # Needs to be created beforehand\n    prefix = \"airless/core/dev\"                 # Path within the bucket for this state\n  }\n}\n</code></pre></p> <p><code>provider.tf</code> <pre><code>provider \"google\" {\n  project = var.project_id\n  region  = var.region\n}\n</code></pre></p> <p>Root <code>main.tf</code> <pre><code>resource \"google_storage_bucket\" \"function_code_bucket\" {\n  name     = \"${var.env}-airless-function-code\"\n  location = var.region\n}\n\n# Example of creating a topic needed by the error function\nresource \"google_pubsub_topic\" \"pubsub_to_bq\" {\n  name = \"${var.env}-pubsub-to-bq\"\n}\n\nmodule \"airless_core\" {\n  source = \"./modules/airless-core\" # Or path/URL to your module\n\n  project_id = var.project_id\n  region     = var.region\n  env        = var.env\n  log_level  = var.log_level\n\n  function_bucket = {\n    id   = google_storage_bucket.function_code_bucket.id\n    name = google_storage_bucket.function_code_bucket.name\n  }\n\n  queue_topic_pubsub_to_bq = {\n    id   = google_pubsub_topic.pubsub_to_bq.id\n    name = google_pubsub_topic.pubsub_to_bq.name\n  }\n\n  source_archive_exclude = [\n    \".*\",\n    \"__pycache__\",\n    \"*.pyc\"\n  ]\n}\n</code></pre></p>"},{"location":"tutorials/gcp/core-infrastructure/#core-function-importance","title":"Core Function Importance","text":"<p>The Airless core infrastructure includes several specialized functions. Their importance generally follows this hierarchy:</p> <ol> <li>Error Function (<code>error.tf</code>): This is arguably the most critical function. It acts as a centralized sink for all errors occurring in other functions. Its responsibilities include logging the error details (to BigQuery via another queue/function or Google Cloud Storage in the <code>_raw</code> bucket), implementing retry logic (using the Delay function), and triggering notifications. Without robust error handling, workflows become brittle and prone to data loss.</li> <li>Delay Function (<code>delay.tf</code>) &amp; Redirect Function (<code>redirect.tf</code>): These enable core workflow patterns.<ul> <li>Delay: Allows introducing controlled pauses in a workflow (e.g., for rate limiting, waiting for long external processes, or implementing exponential backoff for retries directed by the Error function).</li> <li>Redirect: Enables fanning out tasks. A single message can be duplicated and sent to multiple different downstream topics/functions, facilitating parallel processing and complex branching logic.</li> </ul> </li> <li>Email (<code>email.tf</code>) &amp; Slack (<code>slack.tf</code>) Notification Functions: These are primarily for monitoring and alerting. While important for operational visibility, the core workflow can often function without them (though you wouldn't know if something went wrong!). They decouple the notification logic (SMTP details, Slack API tokens) from the business logic functions, making the system cleaner. They are often triggered by the Error function or at specific success/milestone points in a workflow.</li> </ol>"},{"location":"tutorials/gcp/core-infrastructure/#terraform-code-for-airless-core-infrastructure","title":"Terraform Code for Airless Core Infrastructure","text":"<p>Below is the Terraform code based on the files you provided, structured as a module, along with explanations.</p>"},{"location":"tutorials/gcp/core-infrastructure/#file-structure-for-the-module","title":"File Structure for the Module","text":"<pre><code>modules/\n\u2514\u2500\u2500 airless-core/\n    \u251c\u2500\u2500 main.tf\n    \u251c\u2500\u2500 variables.tf\n    \u251c\u2500\u2500 outputs.tf\n    \u251c\u2500\u2500 storage.tf\n    \u251c\u2500\u2500 error.tf\n    \u251c\u2500\u2500 delay.tf\n    \u251c\u2500\u2500 redirect.tf\n    \u251c\u2500\u2500 email.tf\n    \u251c\u2500\u2500 slack.tf\n    \u2514\u2500\u2500 function/       # Directory containing function source\n        \u2514\u2500\u2500 core/\n            \u251c\u2500\u2500 main.py\n            \u2514\u2500\u2500 requirements.txt\n            \u2514\u2500\u2500 ... # Other Python code/dependencies\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#variablestf","title":"<code>variables.tf</code>","text":"<ul> <li>Defines the inputs required by the module. This makes the module configurable.</li> <li>Includes essential parameters like GCP <code>project_id</code>, <code>region</code>, <code>env</code> (environment name like 'dev' or 'prod'), <code>log_level</code>, buckets for function code and data (<code>function_bucket</code>, implicitly created <code>datalake_*</code>), error handling configuration (<code>error_config</code>), and dependencies like external queues (<code>queue_topic_pubsub_to_bq</code>).</li> </ul> modules/airless-core/variables.tf<pre><code>variable \"project_id\" {\n  description = \"GCP Project ID where resources will be deployed.\"\n  type        = string\n}\n\nvariable \"region\" {\n  description = \"GCP Region to create the resources in.\"\n  type        = string\n}\n\nvariable \"env\" {\n  description = \"Deployment environment (e.g., 'dev', 'staging', 'prod'). Used as a prefix for resource names.\"\n  type        = string\n}\n\nvariable \"log_level\" {\n  description = \"Default log level for Cloud Functions (e.g., 'DEBUG', 'INFO', 'WARNING').\"\n  type        = string\n  default     = \"INFO\"\n}\n\nvariable \"function_bucket\" {\n  description = \"Bucket object containing the ID and name for storing Cloud Function source code zip files.\"\n  type = object({\n    id   = string\n    name = string\n  })\n}\n\nvariable \"queue_topic_pubsub_to_bq\" {\n  description = \"Pub/Sub topic object (id, name) used by the Error function to send structured error logs, potentially to a BigQuery sink.\"\n  type = object({\n    id   = string\n    name = string\n  })\n}\n\nvariable \"source_archive_exclude\" {\n  description = \"Set of file patterns to exclude when creating the function source code zip archive.\"\n  type        = set(string)\n  default = [\n    \".*\",\n    \"__pycache__\",\n    \"*.pyc\"\n  ]\n}\n\nvariable \"error_config\" {\n  description = \"Configuration for error handling, including BigQuery logging, email, and Slack notifications.\"\n  type = object({\n    bigquery = object({\n      dataset = string\n      table   = string\n    })\n    email = object({\n      sender     = string\n      recipients = list(string)\n    })\n    slack = object({\n      channels = list(string)\n    })\n  })\n}\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#maintf","title":"<code>main.tf</code>","text":"<ul> <li>This file handles the packaging and uploading of the Cloud Function source code.</li> <li><code>data \"archive_file\" \"source_core\"</code>: Zips the contents of the <code>../function/core</code> directory (relative to this <code>main.tf</code> file). It excludes files matching patterns in <code>var.source_archive_exclude</code>. The <code>output_path</code> is a temporary location for the zip file.</li> <li><code>resource \"google_storage_bucket_object\" \"zip_core\"</code>: Uploads the generated zip file (<code>data.archive_file.source_core.output_path</code>) to the GCS bucket specified by <code>var.function_bucket.name</code>. The object name includes the MD5 hash of the zip file (<code>data.archive_file.source_core.output_md5</code>) to ensure that changes in the source code result in a new object, triggering function updates.</li> </ul> modules/airless-core/main.tf<pre><code>data \"archive_file\" \"source_core\" {\n  type        = \"zip\"\n  # Assumes your Python code for the core functions is in ./function/core/\n  source_dir  = \"${path.module}/function/core\"\n  output_path = \"/tmp/function-core-${var.env}.zip\" # Use a unique temp path\n  excludes    = var.source_archive_exclude\n}\n\nresource \"google_storage_bucket_object\" \"zip_core\" {\n  source       = data.archive_file.source_core.output_path\n  content_type = \"application/zip\"\n  # Name includes hash to trigger updates when code changes\n  name         = \"src/core-${data.archive_file.source_core.output_md5}.zip\"\n  bucket       = var.function_bucket.name\n\n  # Ensure the archive is created before trying to upload\n  depends_on = [\n    data.archive_file.source_core\n  ]\n}\n</code></pre> <p>Note: Ensure the <code>function/core</code> directory exists adjacent to your module's <code>.tf</code> files and contains <code>main.py</code>, <code>requirements.txt</code>, and any other necessary Python code.</p>"},{"location":"tutorials/gcp/core-infrastructure/#functioncoremainpy-example-entry-point","title":"<code>function/core/main.py</code> (Example Entry Point)","text":"<ul> <li>This Python code is the entry point for all the core Cloud Functions defined in this module.</li> <li>It uses an environment variable <code>OPERATOR_IMPORT</code> (set in the Terraform resource definitions) to dynamically import the correct Airless operator class for the specific function (e.g., <code>GoogleErrorReprocessOperator</code>, <code>GoogleDelayOperator</code>).</li> <li>The <code>route</code> function is triggered by the Cloud Event (e.g., Pub/Sub message) and calls the <code>run</code> method of the dynamically loaded operator instance.</li> </ul> modules/airless-core/function/core/main.py<pre><code>import functions_framework\nimport os\n\nfrom airless.core.utils import get_config\n\n# Dynamically import the operator based on environment variable\nexec(f'{get_config(\"OPERATOR_IMPORT\")} as OperatorClass')\n\n@functions_framework.cloud_event\ndef route(cloud_event):\n    \"\"\"\n    Cloud Function entry point triggered by a Pub/Sub event.\n    Dynamically routes the event to the appropriate Airless operator.\n    \"\"\"\n    # Instantiate the dynamically loaded operator class\n    operator_instance = OperatorClass()\n    # Run the operator with the incoming event data\n    operator_instance.run(cloud_event)\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#functioncorerequirementstxt-example-dependencies","title":"<code>function/core/requirements.txt</code> (Example Dependencies)","text":"<ul> <li>Lists the Python packages required by the core functions. These will be installed when GCP builds the function environment.</li> </ul> modules/airless-core/function/core/requirements.txt<pre><code>airless-google-cloud-secret-manager~=0.1.0\nairless-google-cloud-storage~=0.1.0\nairless-google-cloud-bigquery~=0.1.0\nairless-slack~=0.1.0\nairless-email~=0.1.0\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#storagetf","title":"<code>storage.tf</code>","text":"<ul> <li>Defines the Google Cloud Storage (GCS) buckets.</li> <li><code>google_storage_bucket</code>: Creates buckets for different data stages:<ul> <li><code>raw</code>: For storing raw/error data, potentially with lifecycle rules.</li> <li><code>landing</code>: Main landing zone for incoming data.</li> </ul> </li> <li><code>lifecycle_rule</code>: Automatically manages objects in the bucket (e.g., moves objects older than 30 days to ARCHIVE storage class to save costs).</li> <li><code>force_destroy = false</code>: A safety measure to prevent accidental deletion of buckets containing data when running <code>terraform destroy</code>. Set to <code>true</code> only for temporary/test buckets.</li> </ul> modules/airless-core/storage.tf<pre><code>resource \"google_storage_bucket\" \"datalake_raw\" {\n  project       = var.project_id\n  name          = \"${var.env}-datalake-raw\"\n  location      = var.region\n  force_destroy = false\n\n  uniform_bucket_level_access = true\n\n  # Example Lifecycle Rule: Move data to Archive after 30 days\n  lifecycle_rule {\n    condition {\n      age = 30 # Number of days\n    }\n    action {\n      type          = \"SetStorageClass\"\n      storage_class = \"ARCHIVE\"\n    }\n  }\n}\n\nresource \"google_storage_bucket\" \"datalake_landing\" {\n  project       = var.project_id\n  name          = \"${var.env}-datalake-landing\"\n  location      = var.region\n  force_destroy = false\n\n  uniform_bucket_level_access = true\n\n  # Example Lifecycle Rule: Move data to Archive after 30 days\n  lifecycle_rule {\n    condition {\n      age = 30\n    }\n    action {\n      type          = \"SetStorageClass\"\n      storage_class = \"ARCHIVE\"\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#errortf","title":"<code>error.tf</code>","text":"<ul> <li>Defines the critical Error Handling function and its trigger topic.</li> <li><code>google_pubsub_topic \"error_reprocess\"</code>: Creates the Pub/Sub topic where other functions will send messages when they encounter errors.</li> <li><code>google_cloudfunctions2_function \"error_reprocess\"</code>: Defines the Cloud Function itself.<ul> <li><code>build_config</code>: Specifies the runtime (<code>python312</code>), entry point (<code>route</code> in <code>main.py</code>), and the source code location (the <code>zip_core</code> object uploaded in <code>main.tf</code>).</li> <li><code>service_config</code>: Configures runtime settings like memory (<code>256Mi</code>), timeout (<code>540s</code>), and crucial <code>environment_variables</code>:<ul> <li><code>ENV</code>, <code>GCP_PROJECT</code>, <code>LOG_LEVEL</code>: Basic environment info.</li> <li><code>OPERATOR_IMPORT</code>: Tells <code>main.py</code> to load the <code>GoogleErrorReprocessOperator</code>.</li> <li><code>QUEUE_TOPIC_ERROR</code>: Itself, in case it needs to resubmit for retry after delay.</li> <li><code>QUEUE_TOPIC_EMAIL_SEND</code>, <code>QUEUE_TOPIC_SLACK_SEND</code>: Topics for sending notifications.</li> <li><code>QUEUE_TOPIC_PUBSUB_TO_BQ</code>: Topic for sending structured logs to BigQuery (via <code>var.queue_topic_pubsub_to_bq</code>).</li> <li><code>BIGQUERY_DATASET_ERROR</code>, <code>BIGQUERY_TABLE_ERROR</code>: Target for error logging.</li> <li><code>EMAIL_SENDER_ERROR</code>, <code>EMAIL_RECIPIENTS_ERROR</code>, <code>SLACK_CHANNELS_ERROR</code>: Notification details from <code>var.error_config</code>.</li> </ul> </li> <li><code>event_trigger</code>: Configures the function to be triggered by messages published to the <code>google_pubsub_topic.error_reprocess.id</code> topic. <code>retry_policy = \"RETRY_POLICY_RETRY\"</code> means GCP will attempt redelivery on transient issues, but the operator logic handles application-level retries.</li> <li><code>depends_on</code>: Ensures the source code zip and necessary topics exist before creating the function.</li> </ul> </li> </ul> modules/airless-core/error.tf<pre><code>resource \"google_pubsub_topic\" \"error_reprocess\" {\n  project = var.project_id\n  name    = \"${var.env}-error\"\n}\n\nresource \"google_cloudfunctions2_function\" \"error_reprocess\" {\n  project     = var.project_id\n  name        = \"${var.env}-error-reprocess\"\n  location    = var.region\n  description = \"Airless: Handles errors, retries, logging, and notifications.\"\n\n  labels = {\n    \"airless-role\" = \"error-handler\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\" # Function name in main.py\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 100 # Adjust as needed\n    min_instance_count  = 0   # Scale to zero when idle\n    available_memory    = \"256Mi\"\n    timeout_seconds     = 540 # Max timeout for Gen2 PubSub functions\n    environment_variables = {\n      ENV                      = var.env\n      OPERATOR_IMPORT          = \"from airless.google.cloud.core.operator import GoogleErrorReprocessOperator\"\n      GCP_PROJECT              = var.project_id\n      LOG_LEVEL                = var.log_level\n      # Self-reference for potential delayed retries\n      QUEUE_TOPIC_ERROR        = google_pubsub_topic.error_reprocess.name\n      # Notification topics (defined in email.tf/slack.tf)\n      QUEUE_TOPIC_EMAIL_SEND   = google_pubsub_topic.error_notification_email_send.name\n      QUEUE_TOPIC_SLACK_SEND   = google_pubsub_topic.error_notification_slack_send.name\n      # Topic for structured logging (passed in as variable)\n      QUEUE_TOPIC_PUBSUB_TO_BQ = var.queue_topic_pubsub_to_bq.name\n      # Config from variables for the operator\n      BIGQUERY_DATASET_ERROR   = var.error_config.bigquery.dataset\n      BIGQUERY_TABLE_ERROR     = var.error_config.bigquery.table\n      EMAIL_SENDER_ERROR       = var.error_config.email.sender\n      EMAIL_RECIPIENTS_ERROR   = jsonencode(var.error_config.email.recipients) # Pass list as JSON string\n      SLACK_CHANNELS_ERROR     = jsonencode(var.error_config.slack.channels)  # Pass list as JSON string\n    }\n    # Add service account email if using non-default permissions\n    # service_account_email = google_service_account.airless_core.email\n  }\n\n  event_trigger {\n    trigger_region = var.region # Can be omitted to use function region\n    event_type     = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic   = google_pubsub_topic.error_reprocess.id\n    retry_policy   = \"RETRY_POLICY_RETRY\" # Basic GCP retry for infrastructure issues\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.error_reprocess,\n    # Ensure notification topics exist before error function depends on them\n    google_pubsub_topic.error_notification_email_send,\n    google_pubsub_topic.error_notification_slack_send\n    # var.queue_topic_pubsub_to_bq # Topic resource should be created outside the module\n  ]\n}\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#delaytf","title":"<code>delay.tf</code>","text":"<ul> <li>Defines the Delay function and its topic.</li> <li>Structure is very similar to <code>error.tf</code>.</li> <li><code>google_pubsub_topic \"delay\"</code>: Topic to send messages to when a delay is needed.</li> <li><code>google_cloudfunctions2_function \"delay\"</code>:<ul> <li><code>OPERATOR_IMPORT</code>: Set to load the <code>GoogleDelayOperator</code>.</li> <li><code>QUEUE_TOPIC_ERROR</code>: Specifies where this function should send errors if it fails.</li> <li><code>retry_policy = \"RETRY_POLICY_DO_NOT_RETRY\"</code>: This function's core job is delay/retry logic; standard GCP retries might interfere. Failures should likely go straight to the error topic.</li> </ul> </li> </ul> modules/airless-core/delay.tf<pre><code>resource \"google_pubsub_topic\" \"delay\" {\n  project = var.project_id\n  name    = \"${var.env}-delay\"\n}\n\nresource \"google_cloudfunctions2_function\" \"delay\" {\n  project     = var.project_id\n  name        = \"${var.env}-delay\"\n  location    = var.region\n  description = \"Airless: Introduces delays into workflows (e.g., for retries, rate limiting).\"\n\n  labels = {\n    \"airless-role\" = \"delay-handler\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\"\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 100\n    min_instance_count  = 0\n    available_memory    = \"256Mi\"\n    timeout_seconds     = 540\n    environment_variables = {\n      ENV               = var.env\n      OPERATOR_IMPORT   = \"from airless.google.cloud.core.operator import GoogleDelayOperator\"\n      GCP_PROJECT       = var.project_id\n      LOG_LEVEL         = var.log_level\n      QUEUE_TOPIC_ERROR = google_pubsub_topic.error_reprocess.name # Send errors here\n    }\n    # service_account_email = google_service_account.airless_core.email\n  }\n\n  event_trigger {\n    event_type   = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic = google_pubsub_topic.delay.id\n    # Usually, delay logic is precise; don't rely on GCP auto-retry here.\n    # Errors should go to the main error handler via QUEUE_TOPIC_ERROR.\n    retry_policy = \"RETRY_POLICY_DO_NOT_RETRY\"\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.delay,\n    google_pubsub_topic.error_reprocess # Ensure error topic exists\n  ]\n}\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#redirecttf","title":"<code>redirect.tf</code>","text":"<ul> <li>Defines the Redirect function(s) and associated topics.</li> <li>Includes two topics/functions (<code>redirect</code> and <code>redirect_medium</code>) potentially for different scaling/resource needs (e.g., <code>redirect_medium</code> has more memory <code>512Mi</code>). This allows routing redirection tasks based on expected fan-out load.</li> <li><code>google_cloudfunctions2_function \"redirect\"</code> / <code>\"redirect_medium\"</code>:<ul> <li><code>OPERATOR_IMPORT</code>: Loads the <code>GoogleRedirectOperator</code>.</li> <li><code>QUEUE_TOPIC_ERROR</code>: Specifies the error topic.</li> <li><code>retry_policy = \"RETRY_POLICY_RETRY\"</code>: Basic GCP retries are acceptable here.</li> </ul> </li> </ul> modules/airless-core/redirect.tf<pre><code>resource \"google_pubsub_topic\" \"redirect\" {\n  project = var.project_id\n  name    = \"${var.env}-redirect\"\n}\n\nresource \"google_pubsub_topic\" \"redirect_medium\" {\n  project = var.project_id\n  name    = \"${var.env}-redirect-medium\" # Topic for potentially larger fan-outs\n}\n\n\nresource \"google_cloudfunctions2_function\" \"redirect\" {\n  project     = var.project_id\n  name        = \"${var.env}-redirect\"\n  location    = var.region\n  description = \"Airless: Redirects/fans-out a single message to multiple topics.\"\n\n  labels = {\n    \"airless-role\" = \"redirect-handler\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\"\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 10 # Lower default max instances, adjust if needed\n    min_instance_count  = 0\n    available_memory    = \"256Mi\"\n    timeout_seconds     = 540\n    environment_variables = {\n      ENV               = var.env\n      OPERATOR_IMPORT   = \"from airless.google.cloud.core.operator import GoogleRedirectOperator\"\n      GCP_PROJECT       = var.project_id\n      LOG_LEVEL         = \"DEBUG\" # Often useful to debug redirection logic\n      QUEUE_TOPIC_ERROR = google_pubsub_topic.error_reprocess.name\n    }\n    # service_account_email = google_service_account.airless_core.email\n  }\n\n  event_trigger {\n    event_type   = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic = google_pubsub_topic.redirect.id\n    retry_policy = \"RETRY_POLICY_RETRY\"\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.redirect,\n    google_pubsub_topic.error_reprocess\n  ]\n}\n\nresource \"google_cloudfunctions2_function\" \"redirect_medium\" {\n  project     = var.project_id\n  name        = \"${var.env}-redirect-medium\"\n  location    = var.region\n  description = \"Airless: Redirects/fans-out (medium instance size).\"\n\n  labels = {\n    \"airless-role\" = \"redirect-handler-medium\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\"\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 10\n    min_instance_count  = 0\n    available_memory    = \"512Mi\" # More memory than standard redirect\n    timeout_seconds     = 540\n    environment_variables = {\n      ENV               = var.env\n      OPERATOR_IMPORT   = \"from airless.google.cloud.core.operator import GoogleRedirectOperator\"\n      GCP_PROJECT       = var.project_id\n      LOG_LEVEL         = \"DEBUG\"\n      QUEUE_TOPIC_ERROR = google_pubsub_topic.error_reprocess.name\n    }\n    # service_account_email = google_service_account.airless_core.email\n  }\n\n  event_trigger {\n    event_type   = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic = google_pubsub_topic.redirect_medium.id\n    retry_policy = \"RETRY_POLICY_RETRY\"\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.redirect_medium,\n    google_pubsub_topic.error_reprocess\n  ]\n}\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#emailtf","title":"<code>email.tf</code>","text":"<ul> <li>Defines functions and topics for sending emails.</li> <li>Separates topics/functions for regular notifications (<code>notification_email_send</code>) and error notifications (<code>error_notification_email_send</code>). This allows using different SMTP configurations (via Secret Manager secrets <code>smtp</code> vs <code>smtp_error</code>) or different scaling/retry policies if needed.</li> <li><code>google_cloudfunctions2_function \"notification_email_send\"</code> / <code>\"error_notification_email_send\"</code>:<ul> <li><code>OPERATOR_IMPORT</code>: Loads the <code>GoogleEmailSendOperator</code>.</li> <li><code>SECRET_SMTP</code>: Environment variable expected by the operator to specify the name of the secret in GCP Secret Manager containing SMTP credentials (e.g., host, port, user, password). The module assumes secrets named <code>smtp</code> and <code>smtp_error</code> exist.</li> <li><code>max_instance_count = 1</code>: Limits concurrency, often desirable for external notification systems to avoid rate limits or being flagged as spam.</li> <li><code>retry_policy = \"RETRY_POLICY_RETRY\"</code>: Allows GCP retries for transient SMTP issues.</li> </ul> </li> </ul> modules/airless-core/email.tf<pre><code>resource \"google_pubsub_topic\" \"notification_email_send\" {\n  project = var.project_id\n  name    = \"${var.env}-notification-email-send\"\n}\n\n# Separate topic/function for error emails allows different config/scaling if needed\nresource \"google_pubsub_topic\" \"error_notification_email_send\" {\n  project = var.project_id\n  name    = \"${var.env}-error-notification-email-send\"\n}\n\nresource \"google_cloudfunctions2_function\" \"notification_email_send\" {\n  project     = var.project_id\n  name        = \"${var.env}-notification-email-send\"\n  location    = var.region\n  description = \"Airless: Sends standard email notifications via configured SMTP secret ('smtp').\"\n\n  labels = {\n    \"airless-role\" = \"email-notifier\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\"\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 1 # Limit concurrency for email sending\n    min_instance_count  = 0\n    available_memory    = \"256Mi\"\n    timeout_seconds     = 60 # Email sending should be quick\n    environment_variables = {\n      ENV               = var.env\n      OPERATOR_IMPORT   = \"from airless.email.operator import GoogleEmailSendOperator\"\n      GCP_PROJECT       = var.project_id\n      LOG_LEVEL         = var.log_level\n      QUEUE_TOPIC_ERROR = google_pubsub_topic.error_reprocess.name\n      # Operator expects secret name containing SMTP details (host, port, user, pass)\n      SECRET_SMTP       = \"smtp\"\n    }\n    # Requires permissions to access Secret Manager\n    # service_account_email = google_service_account.airless_core.email\n  }\n\n  event_trigger {\n    event_type   = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic = google_pubsub_topic.notification_email_send.id\n    retry_policy = \"RETRY_POLICY_RETRY\"\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.notification_email_send,\n    google_pubsub_topic.error_reprocess\n  ]\n}\n\nresource \"google_cloudfunctions2_function\" \"error_notification_email_send\" {\n  project     = var.project_id\n  name        = \"${var.env}-error-notification-email-send\"\n  location    = var.region\n  description = \"Airless: Sends error email notifications via configured SMTP secret ('smtp_error').\"\n\n  labels = {\n    \"airless-role\" = \"email-error-notifier\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\"\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 1 # Limit concurrency\n    min_instance_count  = 0\n    available_memory    = \"256Mi\"\n    timeout_seconds     = 540 # Allow longer timeout for potential error handling delays\n    environment_variables = {\n      ENV               = var.env\n      OPERATOR_IMPORT   = \"from airless.email.operator import GoogleEmailSendOperator\"\n      GCP_PROJECT       = var.project_id\n      LOG_LEVEL         = var.log_level\n      QUEUE_TOPIC_ERROR = google_pubsub_topic.error_reprocess.name\n      # Use a potentially different secret for error emails\n      SECRET_SMTP       = \"smtp_error\"\n    }\n    # service_account_email = google_service_account.airless_core.email\n  }\n\n  event_trigger {\n    event_type   = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic = google_pubsub_topic.error_notification_email_send.id\n    retry_policy = \"RETRY_POLICY_RETRY\"\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.error_notification_email_send,\n    google_pubsub_topic.error_reprocess\n  ]\n}\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#slacktf","title":"<code>slack.tf</code>","text":"<ul> <li>Defines functions and topics for Slack notifications.</li> <li>Includes separate topics/functions for standard (<code>notification_slack_send</code>) and error (<code>error_notification_slack_send</code>) messages, allowing different Slack App configurations/tokens (via secrets like <code>slack_alert</code>) if needed.</li> <li>Adds a <code>slack_react</code> function/topic, presumably to add emoji reactions to messages, perhaps indicating processing status.</li> <li><code>google_cloudfunctions2_function \"notification_slack_send\"</code> / <code>\"error_notification_slack_send\"</code> / <code>\"slack_react\"</code>:<ul> <li><code>OPERATOR_IMPORT</code>: Loads <code>GoogleSlackSendOperator</code> or <code>GoogleSlackReactOperator</code>.</li> <li>Environment variables point to the error topic. The operator likely expects Slack API tokens/details to be stored in Secret Manager (though the specific secret name isn't defined via env var here, the operator might have a default like <code>slack_alert</code> or <code>slack_token</code>).</li> <li><code>max_instance_count = 1</code> and short timeouts are common for notification functions.</li> </ul> </li> </ul> modules/airless-core/slack.tf<pre><code>resource \"google_pubsub_topic\" \"notification_slack_send\" {\n  project = var.project_id\n  name    = \"${var.env}-notification-slack-message-send\"\n}\n\nresource \"google_pubsub_topic\" \"error_notification_slack_send\" {\n  project = var.project_id\n  name    = \"${var.env}-error-notification-slack-message-send\"\n}\n\nresource \"google_pubsub_topic\" \"slack_react\" {\n  project = var.project_id\n  name    = \"${var.env}-slack-react\"\n}\n\nresource \"google_cloudfunctions2_function\" \"notification_slack_send\" {\n  project     = var.project_id\n  name        = \"${var.env}-notification-slack-send\"\n  location    = var.region\n  description = \"Airless: Sends standard Slack notifications via configured API secret.\"\n\n  labels = {\n    \"airless-role\" = \"slack-notifier\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\"\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 1 # Limit concurrency for Slack API calls\n    min_instance_count  = 0\n    available_memory    = \"256Mi\"\n    timeout_seconds     = 540 # Generous timeout, but should be quick\n    environment_variables = {\n      ENV               = var.env\n      OPERATOR_IMPORT   = \"from airless.slack.operator import GoogleSlackSendOperator\"\n      GCP_PROJECT       = var.project_id\n      LOG_LEVEL         = var.log_level\n      QUEUE_TOPIC_ERROR = google_pubsub_topic.error_reprocess.name\n      # Operator likely expects a Secret Manager secret name via convention or another env var\n      # e.g., SLACK_SECRET_NAME = \"slack_alert\"\n    }\n    # service_account_email = google_service_account.airless_core.email # Needs Secret Manager access\n  }\n\n  event_trigger {\n    event_type   = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic = google_pubsub_topic.notification_slack_send.id\n    retry_policy = \"RETRY_POLICY_RETRY\"\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.notification_slack_send,\n    google_pubsub_topic.error_reprocess\n  ]\n}\n\n\nresource \"google_cloudfunctions2_function\" \"error_notification_slack_send\" {\n  project     = var.project_id\n  name        = \"${var.env}-error-notification-slack-send\"\n  location    = var.region\n  description = \"Airless: Sends error Slack notifications via configured API secret.\"\n\n  labels = {\n    \"airless-role\" = \"slack-error-notifier\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\"\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 1\n    min_instance_count  = 0\n    available_memory    = \"256Mi\"\n    timeout_seconds     = 540\n    environment_variables = {\n      ENV               = var.env\n      OPERATOR_IMPORT   = \"from airless.slack.operator import GoogleSlackSendOperator\"\n      GCP_PROJECT       = var.project_id\n      LOG_LEVEL         = var.log_level\n      QUEUE_TOPIC_ERROR = google_pubsub_topic.error_reprocess.name\n      # Operator likely expects a Secret Manager secret name\n    }\n    # service_account_email = google_service_account.airless_core.email\n  }\n\n  event_trigger {\n    event_type   = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic = google_pubsub_topic.error_notification_slack_send.id\n    retry_policy = \"RETRY_POLICY_RETRY\"\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.error_notification_slack_send,\n    google_pubsub_topic.error_reprocess\n  ]\n}\n\nresource \"google_cloudfunctions2_function\" \"slack_react\" {\n  project     = var.project_id\n  name        = \"${var.env}-slack-react\"\n  location    = var.region\n  description = \"Airless: Reacts to Slack messages (e.g., adds emojis).\"\n\n  labels = {\n    \"airless-role\" = \"slack-reactor\"\n    \"environment\"  = var.env\n  }\n\n  build_config {\n    runtime     = \"python312\"\n    entry_point = \"route\"\n    source {\n      storage_source {\n        bucket = var.function_bucket.name\n        object = google_storage_bucket_object.zip_core.name\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count  = 1\n    min_instance_count  = 0\n    available_memory    = \"128Mi\" # Reactions likely need less memory\n    timeout_seconds     = 60      # Should be very quick\n    environment_variables = {\n      ENV               = var.env\n      OPERATOR_IMPORT   = \"from airless.slack.operator import GoogleSlackReactOperator\"\n      GCP_PROJECT       = var.project_id\n      LOG_LEVEL         = var.log_level\n      QUEUE_TOPIC_ERROR = google_pubsub_topic.error_reprocess.name\n      # Operator likely expects a Secret Manager secret name\n    }\n    # service_account_email = google_service_account.airless_core.email\n  }\n\n  event_trigger {\n    event_type   = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic = google_pubsub_topic.slack_react.id\n    retry_policy = \"RETRY_POLICY_RETRY\"\n  }\n\n  depends_on = [\n    google_storage_bucket_object.zip_core,\n    google_pubsub_topic.slack_react,\n    google_pubsub_topic.error_reprocess\n  ]\n}\n</code></pre>"},{"location":"tutorials/gcp/core-infrastructure/#outputtf","title":"<code>output.tf</code>","text":"<ul> <li>Defines the outputs of the module. These expose the names and IDs of the created resources, making them easily accessible for use in other parts of your Terraform configuration or for external reference.</li> <li>Outputs include bucket names and Pub/Sub topic details (both <code>id</code> and <code>name</code>).</li> </ul> modules/airless-core/output.tf<pre><code>output \"bucket_datalake_raw_name\" {\n  description = \"Name of the raw data bucket.\"\n  value       = google_storage_bucket.datalake_raw.name\n}\n\noutput \"bucket_datalake_landing_name\" {\n  description = \"Name of the main landing bucket.\"\n  value       = google_storage_bucket.datalake_landing.name\n}\n\n# Outputting PubSub Topics (ID is often needed for triggers/permissions, name for reference/env vars)\noutput \"queue_error\" {\n  description = \"Error reprocess queue details.\"\n  value = {\n    id   = google_pubsub_topic.error_reprocess.id\n    name = google_pubsub_topic.error_reprocess.name\n  }\n}\n\noutput \"queue_delay\" {\n  description = \"Delay queue details.\"\n  value = {\n    id   = google_pubsub_topic.delay.id\n    name = google_pubsub_topic.delay.name\n  }\n}\n\noutput \"queue_redirect\" {\n  description = \"Redirect queue details.\"\n  value = {\n    id   = google_pubsub_topic.redirect.id\n    name = google_pubsub_topic.redirect.name\n  }\n}\n\noutput \"queue_redirect_medium\" {\n  description = \"Redirect medium queue details.\"\n  value = {\n    id   = google_pubsub_topic.redirect_medium.id\n    name = google_pubsub_topic.redirect_medium.name\n  }\n}\n\noutput \"queue_notification_email_send\" {\n  description = \"Standard notification email send queue details.\"\n  value = {\n    id   = google_pubsub_topic.notification_email_send.id\n    name = google_pubsub_topic.notification_email_send.name\n  }\n}\n\noutput \"queue_error_notification_email_send\" {\n  description = \"Error notification email send queue details.\"\n  value = {\n    id   = google_pubsub_topic.error_notification_email_send.id\n    name = google_pubsub_topic.error_notification_email_send.name\n  }\n}\n\noutput \"queue_notification_slack_send\" {\n  description = \"Standard notification Slack send queue details.\"\n  value = {\n    id   = google_pubsub_topic.notification_slack_send.id\n    name = google_pubsub_topic.notification_slack_send.name\n  }\n}\n\noutput \"queue_error_notification_slack_send\" {\n  description = \"Error notification Slack send queue details.\"\n  value = {\n    id   = google_pubsub_topic.error_notification_slack_send.id\n    name = google_pubsub_topic.error_notification_slack_send.name\n  }\n}\n\noutput \"queue_slack_react\" {\n  description = \"Slack react queue details.\"\n  value = {\n    id   = google_pubsub_topic.slack_react.id\n    name = google_pubsub_topic.slack_react.name\n  }\n}\n\n# Add other outputs as needed, e.g., service account emails if created within the module\n</code></pre> <p>This comprehensive setup provides the foundational, reusable Airless core infrastructure on GCP, managed effectively with Terraform. Remember to create the necessary secrets (<code>smtp</code>, <code>smtp_error</code>, Slack tokens) in GCP Secret Manager and grant appropriate IAM permissions to the Cloud Functions' service accounts (especially for accessing Pub/Sub, Storage, Secret Manager, and potentially BigQuery).</p>"},{"location":"tutorials/gcp/multistep/","title":"Multistep Workflow","text":"<p>This quickstart guides you through deploying a workflow to Google Cloud Platform (GCP) that involves multiple steps: first, retrieving the latitude and longitude for a given city name, and second, using those coordinates to fetch the current temperature. This workflow consults two different APIs and logs the results. We will deploy this using Terraform and trigger it via Pub/Sub messages.</p> <p>This quickstart assumes you have:</p> <ul> <li>A local IDE (VS Code, PyCharm, etc.) with Python 3.9+.</li> <li>Terminal access.</li> <li>A Google Cloud Platform account with billing enabled.</li> <li>The <code>gcloud</code> CLI installed and configured (link).</li> <li>Terraform installed (link).</li> <li>Core infrastructure module already defined. (link)</li> </ul>"},{"location":"tutorials/gcp/multistep/#project-structure","title":"Project Structure","text":"<p>You will need to create the following structure:</p> <pre><code>.\n\u251c\u2500\u2500 hook\n\u2502   \u2514\u2500\u2500 api.py           # Hook to interact with external APIs\n\u251c\u2500\u2500 operator\n\u2502   \u2514\u2500\u2500 weather.py       # Operator containing business logic\n\u251c\u2500\u2500 terraform\n\u2502   \u251c\u2500\u2500 main.tf          # Terraform main configuration (provider, backend, archive)\n\u2502   \u251c\u2500\u2500 function.tf      # Terraform resources for Pub/Sub and Cloud Function\n\u2502   \u2514\u2500\u2500 variables.tf     # Terraform input variables\n\u251c\u2500\u2500 main.py              # Cloud Function entry point\n\u251c\u2500\u2500 requirements.txt     # Python dependencies\n\u251c\u2500\u2500 Makefile             # Helper commands for deployment and triggering\n\u2514\u2500\u2500 .env                 # Environment variables for local Terraform execution\n</code></pre> <p>Create the necessary folders:</p> <pre><code>mkdir hook operator terraform\ntouch hook/api.py operator/weather.py terraform/main.tf terraform/function.tf terraform/variables.tf main.py requirements.txt Makefile .env\n</code></pre>"},{"location":"tutorials/gcp/multistep/#hookpy","title":"hook.py","text":"<p>We will reuse the hook from the local example, as its core function\u2014interacting with external APIs\u2014remains the same. It interacts with geocode.xyz and open-meteo.com.</p> hook/api.py<pre><code>import requests\nfrom urllib.parse import quote\nfrom typing import Tuple, Dict, Any\n\nfrom airless.core.hook import BaseHook # (1)!\n\n\nclass ApiHook(BaseHook):\n    \"\"\"A hook to fetch geocode data and weather information.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the ApiHook.\"\"\"\n        super().__init__()\n        self.weather_base_url = 'https://api.open-meteo.com/v1/forecast'\n        self.geocode_base_url = 'https://geocode.xyz'\n\n    def _get_geocode_headers(self) -&gt; Dict[str, str]:\n        \"\"\"Returns headers needed for the geocode.xyz API request.\"\"\"\n        return {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36',\n            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',\n            'accept-language': 'en-US,en;q=0.9',\n            'cache-control': 'no-cache',\n            'pragma': 'no-cache',\n            'priority': 'u=0, i',\n            'sec-ch-ua': '\"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-fetch-dest': 'document',\n            'sec-fetch-mode': 'navigate',\n            'sec-fetch-site': 'none',\n            'sec-fetch-user': '?1',\n            'upgrade-insecure-requests': '1',\n        }\n\n    def get_lat_long_from_city(self, city_name: str) -&gt; Tuple[float, float]: # (2)!\n        \"\"\"\n        Fetch the latitude and longitude for a given city name using geocode.xyz.\n        \"\"\"\n        url = f\"{self.geocode_base_url}/{quote(city_name)}?json=1\"\n        headers = self._get_geocode_headers()\n\n        with requests.Session() as session:\n            response = session.get(url, headers=headers)\n            response.raise_for_status() # (3)!\n            data = response.json()\n            self.logger.debug(f\"Geocode response data: {data}\")\n\n            latitude = float(data['latt'])\n            longitude = float(data['longt'])\n\n            return latitude, longitude\n\n    def get_temperature(self, lat: float, lon: float) -&gt; float: # (4)!\n        \"\"\"\n        Fetch the current temperature for given latitude and longitude using Open-Meteo.\n        \"\"\"\n        params = {\n            'latitude': lat,\n            'longitude': lon,\n            'current': 'temperature_2m'\n        }\n        with requests.Session() as session: # (5)!\n            response = session.get(\n                self.weather_base_url,\n                params=params\n            )\n            response.raise_for_status() # (3)!\n            data = response.json()\n            self.logger.debug(f\"Weather response data: {data}\")\n\n            temperature = data['current']['temperature_2m']\n\n            return temperature\n</code></pre> <ol> <li>Inherits from <code>BaseHook</code> (assuming your package provides this generic base).</li> <li>Method to fetch latitude and longitude for a city.</li> <li>Raises an <code>HTTPError</code> for bad API responses (4xx or 5xx).</li> <li>Method to fetch temperature using latitude and longitude.</li> <li>Uses <code>requests.Session()</code> for efficient connection management.</li> </ol>"},{"location":"tutorials/gcp/multistep/#operatorpy","title":"operator.py","text":"<p>The operator now inherits from a GCP-specific base class (<code>GoogleBaseEventOperator</code>) which knows how to handle Pub/Sub CloudEvents. The core logic using the <code>ApiHook</code> remains.</p> <p>The base operator (<code>GoogleBaseEventOperator</code>) is designed to handle Pub/Sub events and includes error routing. Uncaught exceptions during execution are typically caught by the base operator or the framework and sent to a designated error topic (configured via the <code>QUEUE_TOPIC_ERROR</code> environment variable). This ensures that errors don't cause the function to crash silently and can be processed separately.</p> operator/weather.py<pre><code>from airless.google.cloud.core.operator import GoogleBaseEventOperator # (1)!\nfrom airless.core.utils import get_config # (2)!\n\nfrom hook.api import ApiHook\n\n\nclass WeatherOperator(GoogleBaseEventOperator): # (3)!\n    \"\"\"\n    An operator to fetch geographic coordinates for a city\n    or weather data using coordinates, triggered by Pub/Sub events.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the WeatherOperator.\"\"\"\n        super().__init__()\n        self.api_hook = ApiHook()\n\n    def execute(self, data: dict, topic: str) -&gt; None: # (4)!\n        \"\"\"\n        Routes the request based on 'request_type' from the Pub/Sub message data.\n        \"\"\"\n        request_type = data.get('request_type') # Use .get for safer access\n\n        if request_type == 'temperature': # (5)!\n            self.get_temperature(data, topic)\n        elif request_type == 'city_lat_long':\n            self.get_city_lat_long(data, topic)\n        else:\n            # Error logging is handled by the base operator via report_error\n            # if an exception is raised, or log manually if it's a known invalid state.\n            self.logger.error(f\"Request type '{request_type}' not implemented or missing.\")\n            # Optionally raise an exception to trigger error routing:\n            # raise ValueError(f\"Invalid request_type: {request_type}\")\n\n    def get_city_lat_long(self, data: dict, topic: str) -&gt; None:\n        \"\"\"Fetch the latitude and longitude for a given city name.\"\"\"\n        city_name = data.get('city_name')\n        if not city_name:\n            self.logger.error(\"Missing 'city_name' in request data.\")\n            raise ValueError(\"Missing 'city_name'\") # Trigger error routing\n\n        try:\n            latitude, longitude = self.api_hook.get_lat_long_from_city(city_name)\n            self.logger.info(f\"Successfully fetched coordinates for city: {city_name}.\")\n            self.logger.info(f\"Coordinates for {city_name}: Latitude={latitude}, Longitude={longitude}\")\n            # Publish to the same topic with a different request type to get the temperature\n            self.queue_publish(topic, {\"request_type\": \"temperature\", \"lat\": latitude, \"lon\": longitude}) # (6)!\n        except Exception as e:\n            self.logger.error(f\"Error fetching lat/long for {city_name}: {e}\")\n            # Re-raise to let the base operator handle error routing\n            raise\n\n    def get_temperature(self, data: dict, topic: str) -&gt; None:\n        \"\"\"Fetch the current temperature for given coordinates.\"\"\"\n        lat = data.get('lat')\n        lon = data.get('lon')\n        if lat is None or lon is None:\n            self.logger.error(\"Missing 'lat' or 'lon' in request data.\")\n            raise ValueError(\"Missing 'lat' or 'lon'\") # Trigger error routing\n\n        try:\n            temperature = self.api_hook.get_temperature(lat, lon)\n            self.logger.info(f\"Successfully fetched temperature for ({lat}, {lon}).\")\n            self.logger.info(f\"Temperature at ({lat}, {lon}): {temperature}\u00b0C\")\n            # If you need to send results elsewhere, do it here.\n        except Exception as e:\n            self.logger.error(f\"Error fetching temperature for ({lat}, {lon}): {e}\")\n            # Re-raise to let the base operator handle error routing\n            raise\n</code></pre> <ol> <li>Import the base operator designed for GCP Pub/Sub events.</li> <li>Import utility to get environment variables configured in Terraform.</li> <li>Inherit from <code>GoogleBaseEventOperator</code>.</li> <li>The <code>execute</code> method now receives the decoded Pub/Sub message <code>data</code> and the <code>topic</code> name. The base class handles the CloudEvent decoding.</li> <li>The <code>execute</code> method routes the request based on 'request_type' from the Pub/Sub message data.</li> <li>The <code>get_city_lat_long</code> method fetches the latitude and longitude for a given city name and publishes a new message to the same topic with a different request type to get the temperature.</li> </ol>"},{"location":"tutorials/gcp/multistep/#mainpy","title":"main.py","text":"<p>This is the entry point for the Google Cloud Function. It uses the <code>functions-framework</code> and dynamically imports the operator specified by the <code>OPERATOR_IMPORT</code> environment variable.</p> main.py<pre><code>import functions_framework\nimport os\n\nfrom airless.core.utils import get_config\n\n# Dynamically import the operator based on environment variable\nexec(f'{get_config(\"OPERATOR_IMPORT\")} as OperatorClass') # (1)!\n\n@functions_framework.cloud_event # (2)!\ndef route(cloud_event):\n    \"\"\"\n    Cloud Function entry point triggered by a Pub/Sub event.\n    Dynamically routes the event to the appropriate Airless operator.\n    \"\"\"\n    # Instantiate the dynamically loaded operator class\n    operator_instance = OperatorClass()\n    # Run the operator with the incoming event data\n    operator_instance.run(cloud_event) # (3)!\n</code></pre> <ol> <li><code>exec(f'{get_config(\"OPERATOR_IMPORT\")} as OperatorClass')</code> dynamically imports the operator class based on the <code>OPERATOR_IMPORT</code> environment variable (defined in Terraform). This makes the <code>main.py</code> reusable.</li> <li><code>@functions_framework.cloud_event</code> decorator registers this function to handle Cloud Events.</li> <li><code>operator_instance.run(cloud_event)</code> is called. The <code>GoogleBaseEventOperator</code>'s <code>run</code> method parses the <code>cloud_event</code> (decoding the Pub/Sub message data) and then calls the <code>execute</code> method you defined in <code>WeatherOperator</code> with the extracted <code>data</code> and <code>topic</code>.</li> </ol>"},{"location":"tutorials/gcp/multistep/#requirementstxt","title":"requirements.txt","text":"<p>List the necessary Python packages for the Cloud Function.</p> requirements.txt<pre><code>airless-google-cloud-core~=0.1.2\n</code></pre>"},{"location":"tutorials/gcp/multistep/#env","title":".env","text":"<p>This file is primarily used to provide variables to Terraform when running locally. The deployed function uses environment variables set directly in its Terraform configuration.</p> .env<pre><code># Environment Name (used for naming resources)\nENV=dev\n\n# Logging Level for local testing (Cloud Function level set in Terraform)\nLOG_LEVEL=DEBUG\n\n# --- GCP Configuration ---\n# Replace with your actual GCP Project ID\nGCP_PROJECT=\"your-gcp-project-id\"\nQUEUE_TOPIC_ERROR=\"dev-airless-error\"\n</code></pre> <p>Warning</p> <p>Ensure this file is added to your <code>.gitignore</code> to avoid committing sensitive information like secrets if applicable.</p>"},{"location":"tutorials/gcp/multistep/#makefile","title":"Makefile","text":"<p>Create a <code>Makefile</code> to simplify deployment and testing commands.</p> <p>Makefile Indentation</p> <p>Remember that Makefiles use tabs for indentation, not spaces.</p> Makefile<pre><code>run:\n  @python -c \"from operator.weather import WeatherOperator; WeatherOperator().execute({'request_type': 'temperature', 'lat': 51.5074, 'lon': -0.1278})\"\n</code></pre> <p>This Makefile provides convenient targets:</p> <ul> <li><code>make run</code>: Runs the operator locally.</li> </ul>"},{"location":"tutorials/gcp/multistep/#terraform-configuration","title":"Terraform Configuration","text":"<p>We'll use Terraform to define the GCP infrastructure: a Pub/Sub topic to trigger the function and the Cloud Function itself.</p>"},{"location":"tutorials/gcp/multistep/#variablestf","title":"variables.tf","text":"<p>Defines the input variables for our Terraform configuration.</p> terraform/variables.tf<pre><code>variable \"project_id\" {\n  description = \"The GCP project ID.\"\n  type        = string\n}\n\nvariable \"region\" {\n  description = \"The GCP region to deploy resources in.\"\n  type        = string\n  default     = \"us-central1\" # Or your preferred region\n}\n\nvariable \"env\" {\n  description = \"Deployment environment (e.g., dev, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"log_level\" {\n  description = \"Logging level for the Cloud Function.\"\n  type        = string\n  default     = \"INFO\"\n}\n\nvariable \"function_bucket_name\" {\n  description = \"Name of the GCS bucket to store Cloud Function source code.\"\n  type        = string\n  # Example: default = \"your-prefix-cloud-functions-source\"\n}\n\nvariable \"pubsub_topic_error_name\" {\n  description = \"Name of the Pub/Sub topic for routing function errors.\"\n  type        = string\n  default     = \"dev-airless-error\" # Example, adjust as needed\n}\n\nvariable \"function_name\" {\n  description = \"Base name for the Cloud Function.\"\n  type        = string\n  default     = \"weather-api\"\n}\n\nvariable \"source_archive_exclude\" {\n  description = \"Files/directories to exclude from the source code archive.\"\n  type        = set(string)\n  default = [\n    \".venv\",\n    \".git\",\n    \".terraform\",\n    \"__pycache__\",\n    \"*.pyc\",\n    \"*.zip\" # Exclude the output zip itself\n  ]\n}\n</code></pre>"},{"location":"tutorials/gcp/multistep/#maintf","title":"main.tf","text":"<p>Configures the Terraform provider, backend (optional but recommended), and defines the process for archiving the source code.</p> terraform/main.tf<pre><code># Archive the source code directory into a zip file\ndata \"archive_file\" \"source\" {\n  type        = \"zip\"\n  source_dir  = \"${path.module}/\" # Zips the current directory\n  output_path = \"/tmp/${var.env}-${var.function_name}-source.zip\"\n  excludes    = var.source_archive_exclude\n\n  # Include necessary files/dirs explicitly if source_dir is broader\n  # For this structure, source_dir = \".\" works fine with excludes.\n}\n\n# Upload the zipped source code to GCS\nresource \"google_storage_bucket_object\" \"zip\" {\n  name   = \"${var.env}-${var.function_name}-src-${data.archive_file.source.output_md5}.zip\"\n  bucket = google_storage_bucket.function_source_bucket.name # Use the created bucket name\n  source = data.archive_file.source.output_path\n}\n</code></pre> <p>This defines the packaging (<code>archive_file</code>), the GCS bucket (<code>google_storage_bucket</code>), the upload (<code>google_storage_bucket_object</code>), and the trigger (<code>google_cloud_scheduler_job</code>). It depends on resources defined in <code>function.tf</code>.</p>"},{"location":"tutorials/gcp/multistep/#functiontf","title":"function.tf","text":"<p>Defines the Pub/Sub topic and the Cloud Function resource.</p> terraform/function.tf<pre><code># Pub/Sub Topic to trigger the function\nresource \"google_pubsub_topic\" \"main_topic\" {\n  name = \"${var.env}-${var.function_name}\"\n}\n\n# The Cloud Function resource\nresource \"google_cloudfunctions2_function\" \"main_function\" {\n  name     = \"${var.env}-${var.function_name}\"\n  location = var.region\n  description = \"Airless function to fetch weather data from API\"\n\n  build_config {\n    runtime     = \"python312\" # Or python310, python311, python312\n    entry_point = \"route\"    # Matches the function name in main.py\n    source {\n      storage_source {\n        bucket = google_storage_bucket_object.zip.bucket # Get bucket from the uploaded object\n        object = google_storage_bucket_object.zip.name   # Get object name from the uploaded object\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count = 3 # Limit concurrency\n    available_memory   = \"256Mi\"\n    timeout_seconds    = 60\n    # Define environment variables needed by the function and airless core/gcp libs\n    environment_variables = {\n      ENV                  = var.env\n      LOG_LEVEL            = var.log_level\n      GCP_PROJECT          = var.project_id # Airless GCP libs might need this\n      GCP_REGION           = var.region     # Airless GCP libs might need this\n      OPERATOR_IMPORT      = \"from operator.weather import WeatherOperator\"\n      QUEUE_TOPIC_ERROR    = var.pubsub_topic_error_name # For base operator error routing\n      # Add any other specific env vars your operator/hook might need\n    }\n    # ingress_settings               = \"ALLOW_ALL\" # Default - Allow public access if needed (not for PubSub trigger)\n    # all_traffic_on_latest_revision = true\n  }\n\n  # Configure the trigger (Pub/Sub topic)\n  event_trigger {\n    trigger_region = var.region # Can differ from function region if needed\n    event_type     = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic   = google_pubsub_topic.main_topic.id\n    retry_policy   = \"RETRY_POLICY_RETRY\" # Retry on failure\n  }\n}\n\n# Cloud Scheduler job to periodically trigger the function via Pub/Sub\nresource \"google_cloud_scheduler_job\" \"trigger\" {\n  name        = \"${var.env}-${var.function_name}-trigger\"\n  description = \"Periodically trigger the weather API function\"\n  schedule    = \"*/15 * * * *\" # Trigger every 15 minutes for demo\n  time_zone   = \"America/Sao_Paulo\"\n\n  pubsub_target {\n    # google_pubsub_topic.main_topic is defined in function.tf\n    topic_name = google_pubsub_topic.main_topic.id\n    # Message payload expected by the operator's execute method\n    # Example: New York City\n    data = base64encode(jsonencode({\n      \"request_type\" = \"temperature\",\n      \"lat\"          = 40.7128,\n      \"lon\"          = -74.0060\n    }))\n  }\n}\n</code></pre> <p>This defines the <code>google_pubsub_topic</code> and the <code>google_cloudfunctions2_function</code>, linking it to the topic via <code>event_trigger</code> and configuring its source code, runtime, environment variables, and other settings.</p>"},{"location":"tutorials/gcp/multistep/#deploy-and-run","title":"Deploy and Run","text":"<ol> <li> <p>Initialize Terraform: <pre><code>terraform init\n</code></pre></p> </li> <li> <p>Review Plan (Optional but Recommended): <pre><code>terraform plan\n</code></pre>     Check the output to see what resources Terraform will create.</p> </li> <li> <p>Deploy Resources: <pre><code>terraform apply\n</code></pre>     This command will package your code, upload it, and create the GCS Bucket, Pub/Sub topic, Cloud Function, and Cloud Scheduler job on GCP. It might take a few minutes.</p> </li> <li> <p>Test Manually (Optional):     You can trigger the function immediately without waiting for the scheduler:     <pre><code>gcloud pubsub topics publish dev-weather-api --message '{\"request_type\": \"temperature\", \"lat\": 51.5074, \"lon\": -0.1278}'\n</code></pre>     Check the Cloud Function logs in the GCP Console to see the output and verify the temperature was logged.</p> </li> <li> <p>Monitor: The Cloud Scheduler job is configured (by default) to trigger the function every 15 minutes. You can monitor its executions and the function logs in the GCP Console.</p> </li> </ol>"},{"location":"tutorials/gcp/multistep/#clean-up","title":"Clean Up","text":"<p>To remove all the GCP resources created by this example, run:</p> <p><pre><code>terraform destroy\n</code></pre> Confirm the prompt to delete the resources.</p>"},{"location":"tutorials/gcp/overview/","title":"Overview","text":"<p>This page provides a quick overview and links to detailed tutorials on setting up and using Airless workflows on Google Cloud Platform.</p> <ul> <li> <p> Core GCP Infrastructure (Terraform)</p> <p>Learn how to deploy the essential Airless infrastructure (Cloud Functions, Pub/Sub topics, GCS buckets) on Google Cloud using Terraform. This guide explains the serverless architecture choices, the importance of Terraform for IaC, the role of core functions (Error, Delay, Redirect), and storage configuration.</p> <p> View Tutorial</p> </li> <li> <p> Simple GCP Example (Weather API)</p> <p>Follow a step-by-step quickstart to build and deploy a basic Airless workflow on GCP with Terraform. This example involves fetching weather data from an external API, demonstrating the operator/hook pattern, Cloud Function setup, deployment packaging, and triggering via Cloud Scheduler and Pub/Sub.</p> <p> View Tutorial</p> </li> <li> <p> Multi-step GCP Example (Geocode + Weather)</p> <p>Deploy a multi-step Airless workflow on GCP using Terraform. This example shows how to chain tasks: first fetching geocoordinates for a city name, then using those coordinates to retrieve weather data. It illustrates handling different request types within a single Cloud Function triggered by Pub/Sub.</p> <p> View Tutorial</p> </li> </ul>"},{"location":"tutorials/gcp/simple/","title":"Simple Workflow","text":"<p>This quickstart guides you through installing the <code>airless-core</code> package and its GCP dependencies, setting up a basic workflow that consults a weather API and logs the response, and deploying it as a Cloud Function on Google Cloud Platform (GCP) using Terraform.</p> <p>This quickstart assumes you have:</p> <ul> <li>A local IDE (VS Code, PyCharm, etc.) with Python 3.9+.</li> <li>Terminal access.</li> <li>A Google Cloud Platform account with billing enabled.</li> <li>The <code>gcloud</code> CLI installed and configured (link).</li> <li>Terraform installed (link).</li> <li>Core infrastructure module already defined. (link)</li> </ul>"},{"location":"tutorials/gcp/simple/#set-up-local-environment-install-airless-packages","title":"Set up Local Environment &amp; Install Airless Packages","text":"<p>First, set up a local Python environment to manage dependencies for developing and packaging the function source code.</p> uvpip + venv <pre><code># Create a bare virtual environment (no pyproject.toml needed for this simple example)\nuv venv .venv\nsource .venv/bin/activate # Or .\\venv\\Scripts\\activate.bat / Activate.ps1 on Windows\n# Install necessary packages\nuv pip install airless-core airless-google-cloud-core airless-google-cloud-pubsub functions-framework requests google-cloud-pubsub\n# Generate requirements.txt for Cloud Function deployment\nuv pip freeze &gt; requirements.txt\n</code></pre> <pre><code>python -m venv .venv\n# Activate venv in Mac / Linux\nsource .venv/bin/activate\n# Windows CMD: .venv\\Scripts\\activate.bat\n# Windows PowerShell: .venv\\Scripts\\Activate.ps1\npip install airless-core airless-google-cloud-core airless-google-cloud-pubsub functions-framework requests google-cloud-pubsub\npip freeze &gt; requirements.txt\n</code></pre>"},{"location":"tutorials/gcp/simple/#project-structure","title":"Project Structure","text":"<p>Create the following directory structure for your project:</p> <pre><code>.\n\u251c\u2500\u2500 hook\n\u2502   \u2514\u2500\u2500 api.py         # Code to interact with the external weather API\n\u251c\u2500\u2500 operator\n\u2502   \u2514\u2500\u2500 weather.py     # Business logic using the hook\n\u251c\u2500\u2500 main.py            # GCP Cloud Function entry point\n\u251c\u2500\u2500 requirements.txt   # Python dependencies\n\u251c\u2500\u2500 main.tf            # Main Terraform configuration (source packaging, GCS, Scheduler)\n\u251c\u2500\u2500 function.tf        # Terraform configuration for the Cloud Function &amp; Pub/Sub Topic\n\u251c\u2500\u2500 variables.tf       # Terraform variable definitions\n\u251c\u2500\u2500 Makefile           # Helper commands for deployment and testing\n\u2514\u2500\u2500 .env               # Environment variables (primarily for Makefile/local use)\n</code></pre> <p>Create the necessary folders and empty files:</p> <pre><code>mkdir hook operator\ntouch hook/api.py operator/weather.py main.py main.tf function.tf variables.tf Makefile .env\n# requirements.txt should already exist from the previous step\n</code></pre>"},{"location":"tutorials/gcp/simple/#hookpy","title":"hook.py","text":"<p>This file defines the <code>ApiHook</code>, responsible for fetching data from the external Open-Meteo weather API. It inherits from <code>airless.core.hook.BaseHook</code>.</p> hook/api.py<pre><code>import requests\n\nfrom airless.core.hook import BaseHook\n\n\nclass ApiHook(BaseHook): # (1)!\n    \"\"\"A simple hook to simulate fetching weather data.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the WeatherApiHook.\"\"\"\n        super().__init__()\n        self.base_url = 'https://api.open-meteo.com/v1/forecast'\n\n    def get_temperature(self, lat: float, lon: float) -&gt; float:\n        \"\"\"\n        Fetch the current temperature for a given city.\n\n        Args:\n            lat (float): The latitude of the city.\n            lon (float): The longitude of the city.\n\n        Returns:\n            float: The current temperature in Celsius.\n\n        Raises:\n            requests.exceptions.RequestException: If the API request fails.\n        \"\"\"\n        params = {\n            'latitude': lat,\n            'longitude': lon,\n            'current': 'temperature_2m'\n        }\n        with requests.Session() as session: # (2)!\n            response = session.get(\n                self.base_url,\n                params=params,\n                timeout=10 # Add a timeout\n            )\n            response.raise_for_status() # (3)!\n            data = response.json()\n            self.logger.debug(f\"Response: {data}\") # (4)!\n\n            temperature = data['current']['temperature_2m']\n\n            return temperature\n</code></pre> <ol> <li>Hooks encapsulate interactions with external systems and inherit from <code>BaseHook</code>.</li> <li>Using <code>requests.Session()</code> enhances performance through connection reuse and provides configuration options.</li> <li><code>response.raise_for_status()</code> checks for HTTP errors (4xx, 5xx) and raises an exception if one occurred. This allows Airflow's error handling (or the base operator's error routing) to catch it.</li> <li><code>BaseHook</code> provides a pre-configured logger (<code>self.logger</code>).</li> </ol>"},{"location":"tutorials/gcp/simple/#operatorpy","title":"operator.py","text":"<p>This file defines the <code>WeatherOperator</code>, which contains the core logic. It uses the <code>ApiHook</code> to fetch data and logs the result. For GCP deployment, it inherits from <code>airless.google.cloud.core.operator.GoogleBaseEventOperator</code>, which handles parsing the incoming Cloud Event.</p> operator/weather.py<pre><code>from airless.google.cloud.core.operator import GoogleBaseEventOperator # (1)!\nfrom airless.core.utils import get_config # To read environment variables if needed later\n\nfrom hook.api import ApiHook\n\n\nclass WeatherOperator(GoogleBaseEventOperator): # (2)!\n    \"\"\"A simple operator to fetch weather data triggered by a Cloud Event.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the WeatherOperator.\"\"\"\n        super().__init__()\n        self.api_hook = ApiHook()\n\n    def execute(self, data: dict, topic: str) -&gt; None: # (3)!\n        \"\"\"Define which method to call based on the request type from the event data.\"\"\"\n        request_type = data.get('request_type') # Use .get for safer access\n\n        if request_type == 'temperature':\n            self.get_temperature(data, topic)\n        else:\n            # Log a warning or raise a more specific error if needed\n            self.logger.critical(f\"Request type '{request_type}' not implemented or missing in message data.\")\n            # Optionally raise an exception to trigger error handling/retry\n            # raise ValueError(f\"Request type '{request_type}' not implemented\")\n\n    def get_temperature(self, data: dict, topic: str) -&gt; None:\n        \"\"\"Fetch the current temperature for a given city from message data.\"\"\"\n        lat = data.get('lat')\n        lon = data.get('lon')\n\n        if lat is None or lon is None:\n            self.logger.error(f\"Missing 'lat' or 'lon' in message data: {data}\")\n            # Decide if this should be a hard failure\n            raise ValueError(\"Missing latitude or longitude in input data\")\n\n        try:\n            temperature = self.api_hook.get_temperature(float(lat), float(lon))\n            self.logger.info(f\"Successfully fetched temperature for ({lat}, {lon}): {temperature}\u00b0C\") # (4)!\n        except Exception as e:\n            self.logger.error(f\"Failed to get temperature for ({lat}, {lon}): {e}\")\n            # Re-raise the exception to let the base operator handle error routing\n            raise\n</code></pre> <ol> <li>Import the base operator designed for GCP Cloud Events.</li> <li>Inherit from <code>GoogleBaseEventOperator</code>. This base class handles parsing the incoming <code>cloud_event</code> in <code>main.py</code> and calls the <code>execute</code> method with extracted <code>data</code> and <code>topic</code>.</li> <li>The <code>execute</code> method receives the payload (<code>data</code>) from the Pub/Sub message and the <code>topic</code> name.</li> <li>Use the built-in <code>self.logger</code> for logging. <code>INFO</code> level is often more appropriate for successful execution steps than <code>DEBUG</code>.</li> </ol>"},{"location":"tutorials/gcp/simple/#mainpy","title":"main.py","text":"<p>This is the entry point for the GCP Cloud Function. It uses the <code>functions_framework</code> to handle the incoming Cloud Event trigger (from Pub/Sub), dynamically imports the specified operator, instantiates it, and runs it.</p> main.py<pre><code>import functions_framework\nimport os\n\nfrom airless.core.utils import get_config\n\n# Dynamically import the operator based on environment variable\nexec(f'{get_config(\"OPERATOR_IMPORT\")} as OperatorClass') # (1)!\n\n@functions_framework.cloud_event # (2)!\ndef route(cloud_event):\n    \"\"\"\n    Cloud Function entry point triggered by a Pub/Sub event.\n    Dynamically routes the event to the appropriate Airless operator.\n    \"\"\"\n    # Instantiate the dynamically loaded operator class\n    operator_instance = OperatorClass()\n    # Run the operator with the incoming event data\n    operator_instance.run(cloud_event) # (3)!\n</code></pre> <ol> <li><code>exec(f'{get_config(\"OPERATOR_IMPORT\")} as OperatorClass')</code> dynamically imports the operator class based on the <code>OPERATOR_IMPORT</code> environment variable (defined in Terraform). This makes the <code>main.py</code> reusable.</li> <li><code>@functions_framework.cloud_event</code> decorator registers this function to handle Cloud Events.</li> <li><code>operator_instance.run(cloud_event)</code> is called. The <code>GoogleBaseEventOperator</code>'s <code>run</code> method parses the <code>cloud_event</code> (decoding the Pub/Sub message data) and then calls the <code>execute</code> method you defined in <code>WeatherOperator</code> with the extracted <code>data</code> and <code>topic</code>.</li> </ol>"},{"location":"tutorials/gcp/simple/#requirementstxt","title":"requirements.txt","text":"<p>This file lists the Python dependencies needed by the Cloud Function. It's generated by <code>uv pip freeze</code> or <code>pip freeze</code>.</p> requirements.txt<pre><code>airless-google-cloud-core==&lt;version&gt;\n# Add any other direct or transitive dependencies listed by freeze\n</code></pre> <p>(Note: Replace <code>&lt;version&gt;</code> with the actual versions installed in your environment)</p>"},{"location":"tutorials/gcp/simple/#env","title":".env","text":"<p>Create a <code>.env</code> file in the root directory to store configuration, primarily for the Makefile commands. Remember to add this file to your <code>.gitignore</code>!</p> .env<pre><code># Environment Name (used for naming resources)\nENV=dev\n\n# Logging Level for local testing (Cloud Function level set in Terraform)\nLOG_LEVEL=DEBUG\n\n# --- GCP Configuration ---\n# Replace with your actual GCP Project ID\nGCP_PROJECT=\"your-gcp-project-id\"\nQUEUE_TOPIC_ERROR=\"dev-airless-error\"\n</code></pre> <p>Warning</p> <p>Ensure this file is added to your <code>.gitignore</code> to avoid committing sensitive information like secrets if applicable.</p> <p>Fill in your <code>GCP_PROJECT</code>, <code>GCP_REGION</code></p>"},{"location":"tutorials/gcp/simple/#makefile","title":"Makefile","text":"<p>Create a <code>Makefile</code> to simplify deployment and testing commands.</p> <p>Makefile Indentation</p> <p>Remember that Makefiles use tabs for indentation, not spaces.</p> Makefile<pre><code>run:\n  @python -c \"from operator.weather import WeatherOperator; WeatherOperator().execute({'request_type': 'temperature', 'lat': 51.5074, 'lon': -0.1278})\"\n</code></pre> <p>This Makefile provides convenient targets:</p> <ul> <li><code>make run</code>: Runs the operator locally.</li> </ul>"},{"location":"tutorials/gcp/simple/#error-handling-explanation","title":"Error Handling Explanation","text":"<p>Airless on GCP typically utilizes a centralized error handling mechanism. The <code>GoogleBaseEventOperator</code> is designed to automatically catch uncaught exceptions that occur within your <code>execute</code> method (or methods called by it, like <code>api_hook.get_temperature</code>).</p> <p>When an exception occurs, the base operator formats an error message (including the original message data, topic, and exception details) and publishes it to a designated error Pub/Sub topic. This error topic's name is configured via the <code>QUEUE_TOPIC_ERROR</code> environment variable, which we will set in the Terraform configuration (<code>function.tf</code>).</p> <p>This means you generally don't need explicit <code>try...except</code> blocks for routing errors within your <code>execute</code> method, unless you want to perform specific cleanup or logging before letting the error propagate. The infrastructure for this error topic (and potentially a separate function to consume from it for alerts or retries) needs to exist and be specified for the main function to use. We define the <code>QUEUE_TOPIC_ERROR</code> variable in <code>variables.tf</code> and pass it to the function in <code>function.tf</code>.</p>"},{"location":"tutorials/gcp/simple/#terraform-configuration-terraformvariablestf","title":"Terraform Configuration (<code>terraform/variables.tf</code>)","text":"<p>This file defines the input variables for your Terraform configuration, allowing for customization without changing the main code.</p> terraform/variables.tf<pre><code>variable \"project_id\" {\n  description = \"The GCP project ID.\"\n  type        = string\n}\n\nvariable \"region\" {\n  description = \"The GCP region to deploy resources in.\"\n  type        = string\n  default     = \"us-central1\" # Or your preferred region\n}\n\nvariable \"env\" {\n  description = \"Deployment environment (e.g., dev, prod).\"\n  type        = string\n  default     = \"dev\"\n}\n\nvariable \"log_level\" {\n  description = \"Logging level for the Cloud Function.\"\n  type        = string\n  default     = \"INFO\"\n}\n\nvariable \"function_bucket_name\" {\n  description = \"Name of the GCS bucket to store Cloud Function source code.\"\n  type        = string\n  # Example: default = \"your-prefix-cloud-functions-source\"\n}\n\nvariable \"pubsub_topic_error_name\" {\n  description = \"Name of the Pub/Sub topic for routing function errors.\"\n  type        = string\n  default     = \"dev-airless-error\" # Example, adjust as needed\n}\n\nvariable \"function_name\" {\n  description = \"Base name for the Cloud Function.\"\n  type        = string\n  default     = \"weather-api\"\n}\n\nvariable \"source_archive_exclude\" {\n  description = \"Files/directories to exclude from the source code archive.\"\n  type        = set(string)\n  default = [\n    \".venv\",\n    \".git\",\n    \".terraform\",\n    \"__pycache__\",\n    \"*.pyc\",\n    \"*.zip\" # Exclude the output zip itself\n  ]\n}\n</code></pre> <p>This file defines variables like project ID, region, environment name, bucket name for source code, error topic name, and function settings. Defaults are provided for convenience.</p>"},{"location":"tutorials/gcp/simple/#terraform-configuration-terraformmaintf","title":"Terraform Configuration (<code>terraform/main.tf</code>)","text":"<p>This file sets up the Google provider, creates the source code archive, uploads it to GCS, and defines the Cloud Scheduler job to trigger the workflow periodically.</p> terraform/main.tf<pre><code># Archive the source code directory into a zip file\ndata \"archive_file\" \"source\" {\n  type        = \"zip\"\n  source_dir  = \"${path.module}/\" # Zips the current directory\n  output_path = \"/tmp/${var.env}-${var.function_name}-source.zip\"\n  excludes    = var.source_archive_exclude\n\n  # Include necessary files/dirs explicitly if source_dir is broader\n  # For this structure, source_dir = \".\" works fine with excludes.\n}\n\n# Upload the zipped source code to GCS\nresource \"google_storage_bucket_object\" \"zip\" {\n  name   = \"${var.env}-${var.function_name}-src-${data.archive_file.source.output_md5}.zip\"\n  bucket = google_storage_bucket.function_source_bucket.name # Use the created bucket name\n  source = data.archive_file.source.output_path\n}\n</code></pre> <p>This defines the packaging (<code>archive_file</code>), the GCS bucket (<code>google_storage_bucket</code>), the upload (<code>google_storage_bucket_object</code>), and the trigger (<code>google_cloud_scheduler_job</code>). It depends on resources defined in <code>function.tf</code>.</p>"},{"location":"tutorials/gcp/simple/#terraform-configuration-terraformfunctiontf","title":"Terraform Configuration (<code>terraform/function.tf</code>)","text":"<p>This file defines the Pub/Sub topic that acts as the trigger and the Cloud Function resource itself.</p> terraform/function.tf<pre><code># Pub/Sub Topic to trigger the function\nresource \"google_pubsub_topic\" \"main_topic\" {\n  name = \"${var.env}-${var.function_name}\"\n}\n\n# The Cloud Function resource\nresource \"google_cloudfunctions2_function\" \"main_function\" {\n  name     = \"${var.env}-${var.function_name}\"\n  location = var.region\n  description = \"Airless function to fetch weather data from API\"\n\n  build_config {\n    runtime     = \"python312\" # Or python310, python311, python312\n    entry_point = \"route\"    # Matches the function name in main.py\n    source {\n      storage_source {\n        bucket = google_storage_bucket_object.zip.bucket # Get bucket from the uploaded object\n        object = google_storage_bucket_object.zip.name   # Get object name from the uploaded object\n      }\n    }\n  }\n\n  service_config {\n    max_instance_count = 3 # Limit concurrency\n    available_memory   = \"256Mi\"\n    timeout_seconds    = 60\n    # Define environment variables needed by the function and airless core/gcp libs\n    environment_variables = {\n      ENV                  = var.env\n      LOG_LEVEL            = var.log_level\n      GCP_PROJECT          = var.project_id # Airless GCP libs might need this\n      GCP_REGION           = var.region     # Airless GCP libs might need this\n      OPERATOR_IMPORT      = \"from operator.weather import WeatherOperator\"\n      QUEUE_TOPIC_ERROR    = var.pubsub_topic_error_name # For base operator error routing\n      # Add any other specific env vars your operator/hook might need\n    }\n    # ingress_settings               = \"ALLOW_ALL\" # Default - Allow public access if needed (not for PubSub trigger)\n    # all_traffic_on_latest_revision = true\n  }\n\n  # Configure the trigger (Pub/Sub topic)\n  event_trigger {\n    trigger_region = var.region # Can differ from function region if needed\n    event_type     = \"google.cloud.pubsub.topic.v1.messagePublished\"\n    pubsub_topic   = google_pubsub_topic.main_topic.id\n    retry_policy   = \"RETRY_POLICY_RETRY\" # Retry on failure\n  }\n}\n\n# Cloud Scheduler job to periodically trigger the function via Pub/Sub\nresource \"google_cloud_scheduler_job\" \"trigger\" {\n  name        = \"${var.env}-${var.function_name}-trigger\"\n  description = \"Periodically trigger the weather API function\"\n  schedule    = \"*/15 * * * *\" # Trigger every 15 minutes for demo\n  time_zone   = \"America/Sao_Paulo\"\n\n  pubsub_target {\n    # google_pubsub_topic.main_topic is defined in function.tf\n    topic_name = google_pubsub_topic.main_topic.id\n    # Message payload expected by the operator's execute method\n    # Example: New York City\n    data = base64encode(jsonencode({\n      \"request_type\" = \"temperature\",\n      \"lat\"          = 40.7128,\n      \"lon\"          = -74.0060\n    }))\n  }\n}\n</code></pre> <p>This defines the <code>google_pubsub_topic</code> and the <code>google_cloudfunctions2_function</code>, linking it to the topic via <code>event_trigger</code> and configuring its source code, runtime, environment variables, and other settings.</p>"},{"location":"tutorials/gcp/simple/#deploy-and-run","title":"Deploy and Run","text":"<ol> <li> <p>Initialize Terraform: <pre><code>terraform init\n</code></pre></p> </li> <li> <p>Review Plan (Optional but Recommended): <pre><code>terraform plan\n</code></pre>     Check the output to see what resources Terraform will create.</p> </li> <li> <p>Deploy Resources: <pre><code>terraform apply\n</code></pre>     This command will package your code, upload it, and create the GCS Bucket, Pub/Sub topic, Cloud Function, and Cloud Scheduler job on GCP. It might take a few minutes.</p> </li> <li> <p>Test Manually (Optional):     You can trigger the function immediately without waiting for the scheduler:     <pre><code>gcloud pubsub topics publish dev-weather-api --message '{\"request_type\": \"temperature\", \"lat\": 51.5074, \"lon\": -0.1278}'\n</code></pre>     Check the Cloud Function logs in the GCP Console to see the output and verify the temperature was logged.</p> </li> <li> <p>Monitor: The Cloud Scheduler job is configured (by default) to trigger the function every 15 minutes. You can monitor its executions and the function logs in the GCP Console.</p> </li> </ol>"},{"location":"tutorials/gcp/simple/#clean-up","title":"Clean Up","text":"<p>To remove all the GCP resources created by this example, run:</p> <p><pre><code>terraform destroy\n</code></pre> Confirm the prompt to delete the resources.</p>"},{"location":"tutorials/gcp/simple/#simple-example","title":"Simple Example","text":"<p>Only return a message to pubsub but now using GCP pubsub.</p>"}]}